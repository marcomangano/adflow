!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module adjointextra_b
  implicit none

contains
  subroutine volume_block()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vol = zero
    do k=1,ke
      n = k - 1
      do j=1,je
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x&
&               (i, m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2&
&               ), x(i, m, k, 3), vp1)
          call volpym(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, &
&               m, k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2&
&               ), x(l, j, n, 3), vp2)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, &
&               j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x&
&               (l, j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2&
&               ), x(i, j, n, 3), vp3)
          call volpym(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, &
&               m, n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2&
&               ), x(l, m, k, 3), vp4)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x&
&               (l, m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2&
&               ), x(l, j, k, 3), vp5)
          call volpym(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, &
&               j, n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2&
&               ), x(i, m, n, 3), vp6)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            vol(i, j, k) = vol(i, j, k)
          else
            vol(i, j, k) = -vol(i, j, k)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) vol(1, j, k)&
&          = vol(2, j, k)
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) vol(ie, j, k&
&         ) = vol(il, j, k)
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) vol(i, 1, k)&
&          = vol(i, 2, k)
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) vol(i, je, k&
&         ) = vol(i, jl, k)
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) vol(i, j, 1)&
&          = vol(i, j, 2)
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) vol(i, j, ke&
&         ) = vol(i, j, kl)
      end do
    end do

  contains
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,
!         whose coordinates are set in the subroutine metric itself,
!         is the top node and a-b-c-d is the quadrilateral surface.
!         it is assumed that the cross product vca * vdb points in
!         the direction of the top node. here vca is the diagonal
!         running from node c to node a and vdb the diagonal from
!         node d to node b.
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block
!  differentiation of volume_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *x *vol
!   with respect to varying inputs: *x *vol
!   rw status of diff variables: *x:incr *vol:in-zero
!   plus diff mem management of: x:in vol:in
  subroutine volume_block_b()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xpd, ypd, zpd, vp1d, vp2d, vp3d, vp4d, vp5d, &
&   vp6d
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    integer :: branch
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vol = zero
    do k=1,ke
      call pushinteger4(n)
      n = k - 1
      do j=1,je
        call pushinteger4(m)
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          call pushreal8(xp)
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          call pushreal8(yp)
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          call pushreal8(zp)
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x&
&               (i, m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2&
&               ), x(i, m, k, 3), vp1)
          call volpym(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, &
&               m, k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2&
&               ), x(l, j, n, 3), vp2)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, &
&               j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x&
&               (l, j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2&
&               ), x(i, j, n, 3), vp3)
          call volpym(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, &
&               m, n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2&
&               ), x(l, m, k, 3), vp4)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x&
&               (l, m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2&
&               ), x(l, j, k, 3), vp5)
          call volpym(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, &
&               j, n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2&
&               ), x(i, m, n, 3), vp6)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            call pushcontrol1b(0)
            vol(i, j, k) = vol(i, j, k)
          else
            vol(i, j, k) = -vol(i, j, k)
            call pushcontrol1b(1)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) then
          vol(1, j, k) = vol(2, j, k)
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) then
          tmp = vol(il, j, k)
          vol(ie, j, k) = tmp
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) then
          vol(i, 1, k) = vol(i, 2, k)
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) then
          tmp0 = vol(i, jl, k)
          vol(i, je, k) = tmp0
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) then
          vol(i, j, 1) = vol(i, j, 2)
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) then
          tmp1 = vol(i, j, kl)
          vol(i, j, ke) = tmp1
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do
    end do
    do j=je,1,-1
      do i=ie,1,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          tmpd1 = vold(i, j, ke)
          vold(i, j, ke) = 0.0_8
          vold(i, j, kl) = vold(i, j, kl) + tmpd1
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          vold(i, j, 2) = vold(i, j, 2) + vold(i, j, 1)
          vold(i, j, 1) = 0.0_8
        end if
      end do
    end do
    do k=kl,2,-1
      do i=ie,1,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          tmpd0 = vold(i, je, k)
          vold(i, je, k) = 0.0_8
          vold(i, jl, k) = vold(i, jl, k) + tmpd0
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          vold(i, 2, k) = vold(i, 2, k) + vold(i, 1, k)
          vold(i, 1, k) = 0.0_8
        end if
      end do
    end do
    do k=kl,2,-1
      do j=jl,2,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          tmpd = vold(ie, j, k)
          vold(ie, j, k) = 0.0_8
          vold(il, j, k) = vold(il, j, k) + tmpd
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          vold(2, j, k) = vold(2, j, k) + vold(1, j, k)
          vold(1, j, k) = 0.0_8
        end if
      end do
    end do
    vp1d = 0.0_8
    vp2d = 0.0_8
    vp3d = 0.0_8
    vp4d = 0.0_8
    vp5d = 0.0_8
    vp6d = 0.0_8
    do k=ke,1,-1
      do j=je,1,-1
        do i=ie,1,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) vold(i, j, k) = -vold(i, j, k)
          tempd = sixth*vold(i, j, k)
          vp1d = vp1d + tempd
          vp2d = vp2d + tempd
          vp3d = vp3d + tempd
          vp4d = vp4d + tempd
          vp5d = vp5d + tempd
          vp6d = vp6d + tempd
          vold(i, j, k) = 0.0_8
          l = i - 1
          zpd = 0.0_8
          ypd = 0.0_8
          xpd = 0.0_8
          call volpym_b(x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd&
&                 (i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), x(l, j, n&
&                 , 1), xd(l, j, n, 1), x(l, j, n, 2), xd(l, j, n, 2), x&
&                 (l, j, n, 3), xd(l, j, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(i, m, n, 1), xd(i, m, n, 1), x(i, m&
&                 , n, 2), xd(i, m, n, 2), x(i, m, n, 3), xd(i, m, n, 3)&
&                 , vp6, vp6d)
          vp6d = 0.0_8
          call volpym_b(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, m, k&
&                 , 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i, m, k, 2), x&
&                 (i, m, k, 3), xd(i, m, k, 3), x(l, m, k, 1), xd(l, m, &
&                 k, 1), x(l, m, k, 2), xd(l, m, k, 2), x(l, m, k, 3), &
&                 xd(l, m, k, 3), x(l, j, k, 1), xd(l, j, k, 1), x(l, j&
&                 , k, 2), xd(l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3)&
&                 , vp5, vp5d)
          vp5d = 0.0_8
          call volpym_b(x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd&
&                 (i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), x(i, m, n&
&                 , 1), xd(i, m, n, 1), x(i, m, n, 2), xd(i, m, n, 2), x&
&                 (i, m, n, 3), xd(i, m, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, m, k, 1), xd(l, m, k, 1), x(l, m&
&                 , k, 2), xd(l, m, k, 2), x(l, m, k, 3), xd(l, m, k, 3)&
&                 , vp4, vp4d)
          vp4d = 0.0_8
          call volpym_b(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(l, j, k&
&                 , 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l, j, k, 2), x&
&                 (l, j, k, 3), xd(l, j, k, 3), x(l, j, n, 1), xd(l, j, &
&                 n, 1), x(l, j, n, 2), xd(l, j, n, 2), x(l, j, n, 3), &
&                 xd(l, j, n, 3), x(i, j, n, 1), xd(i, j, n, 1), x(i, j&
&                 , n, 2), xd(i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3)&
&                 , vp3, vp3d)
          vp3d = 0.0_8
          call volpym_b(x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd&
&                 (l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), x(l, m, k&
&                 , 1), xd(l, m, k, 1), x(l, m, k, 2), xd(l, m, k, 2), x&
&                 (l, m, k, 3), xd(l, m, k, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, j, n, 1), xd(l, j, n, 1), x(l, j&
&                 , n, 2), xd(l, j, n, 2), x(l, j, n, 3), xd(l, j, n, 3)&
&                 , vp2, vp2d)
          vp2d = 0.0_8
          call volpym_b(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, j, n&
&                 , 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i, j, n, 2), x&
&                 (i, j, n, 3), xd(i, j, n, 3), x(i, m, n, 1), xd(i, m, &
&                 n, 1), x(i, m, n, 2), xd(i, m, n, 2), x(i, m, n, 3), &
&                 xd(i, m, n, 3), x(i, m, k, 1), xd(i, m, k, 1), x(i, m&
&                 , k, 2), xd(i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3)&
&                 , vp1, vp1d)
          vp1d = 0.0_8
          call popreal8(zp)
          tempd0 = eighth*zpd
          xd(i, j, k, 3) = xd(i, j, k, 3) + tempd0
          xd(i, m, k, 3) = xd(i, m, k, 3) + tempd0
          xd(i, m, n, 3) = xd(i, m, n, 3) + tempd0
          xd(i, j, n, 3) = xd(i, j, n, 3) + tempd0
          xd(l, j, k, 3) = xd(l, j, k, 3) + tempd0
          xd(l, m, k, 3) = xd(l, m, k, 3) + tempd0
          xd(l, m, n, 3) = xd(l, m, n, 3) + tempd0
          xd(l, j, n, 3) = xd(l, j, n, 3) + tempd0
          call popreal8(yp)
          tempd1 = eighth*ypd
          xd(i, j, k, 2) = xd(i, j, k, 2) + tempd1
          xd(i, m, k, 2) = xd(i, m, k, 2) + tempd1
          xd(i, m, n, 2) = xd(i, m, n, 2) + tempd1
          xd(i, j, n, 2) = xd(i, j, n, 2) + tempd1
          xd(l, j, k, 2) = xd(l, j, k, 2) + tempd1
          xd(l, m, k, 2) = xd(l, m, k, 2) + tempd1
          xd(l, m, n, 2) = xd(l, m, n, 2) + tempd1
          xd(l, j, n, 2) = xd(l, j, n, 2) + tempd1
          call popreal8(xp)
          tempd2 = eighth*xpd
          xd(i, j, k, 1) = xd(i, j, k, 1) + tempd2
          xd(i, m, k, 1) = xd(i, m, k, 1) + tempd2
          xd(i, m, n, 1) = xd(i, m, n, 1) + tempd2
          xd(i, j, n, 1) = xd(i, j, n, 1) + tempd2
          xd(l, j, k, 1) = xd(l, j, k, 1) + tempd2
          xd(l, m, k, 1) = xd(l, m, k, 1) + tempd2
          xd(l, m, n, 1) = xd(l, m, n, 1) + tempd2
          xd(l, j, n, 1) = xd(l, j, n, 1) + tempd2
        end do
        call popinteger4(m)
      end do
      call popinteger4(n)
    end do
    vold = 0.0_8

  contains
!  differentiation of volpym in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: xp yp zp xa xb xc xd ya yb
!                yc yd za zb zc zd volume
!   with respect to varying inputs: xp yp zp xa xb xc xd ya yb
!                yc yd za zb zc zd
    subroutine volpym_b(xa, xad, ya, yad, za, zad, xb, xbd, yb, ybd, zb&
&     , zbd, xc, xcd, yc, ycd, zc, zcd, xd, xdd, yd, ydd, zd, zdd, &
&     volume, volumed)
!
!         volpym computes 6 times the volume of a pyramid. node p,
!         whose coordinates are set in the subroutine metric itself,
!         is the top node and a-b-c-d is the quadrilateral surface.
!         it is assumed that the cross product vca * vdb points in
!         the direction of the top node. here vca is the diagonal
!         running from node c to node a and vdb the diagonal from
!         node d to node b.
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
      real(kind=realtype) :: volumed
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype) :: xad, yad, zad, xbd, ybd, zbd
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      real(kind=realtype) :: xcd, ycd, zcd, xdd, ydd, zdd
      real(kind=realtype) :: tempd
      real(kind=realtype) :: tempd7
      real(kind=realtype) :: tempd6
      real(kind=realtype) :: tempd5
      real(kind=realtype) :: tempd4
      real(kind=realtype) :: tempd3
      real(kind=realtype) :: tempd2
      real(kind=realtype) :: tempd1
      real(kind=realtype) :: tempd0
      tempd = ((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))*volumed
      tempd0 = -(fourth*tempd)
      tempd1 = (xp-fourth*(xa+xb+xc+xd))*volumed
      tempd2 = ((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))*volumed
      tempd3 = -(fourth*tempd2)
      tempd4 = (yp-fourth*(ya+yb+yc+yd))*volumed
      tempd5 = ((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))*volumed
      tempd6 = -(fourth*tempd5)
      tempd7 = (zp-fourth*(za+zb+zc+zd))*volumed
      xpd = xpd + tempd
      xad = xad + (yb-yd)*tempd7 - (zb-zd)*tempd4 + tempd0
      xbd = xbd + (za-zc)*tempd4 - (ya-yc)*tempd7 + tempd0
      xcd = xcd + (zb-zd)*tempd4 - (yb-yd)*tempd7 + tempd0
      xdd = xdd + (ya-yc)*tempd7 - (za-zc)*tempd4 + tempd0
      yad = yad + tempd3 - (xb-xd)*tempd7 + (zb-zd)*tempd1
      ycd = ycd + (xb-xd)*tempd7 + tempd3 - (zb-zd)*tempd1
      zbd = zbd + tempd6 - (xa-xc)*tempd4 + (ya-yc)*tempd1
      zdd = zdd + tempd6 + (xa-xc)*tempd4 - (ya-yc)*tempd1
      zad = zad + tempd6 + (xb-xd)*tempd4 - (yb-yd)*tempd1
      zcd = zcd + tempd6 - (xb-xd)*tempd4 + (yb-yd)*tempd1
      ybd = ybd + (xa-xc)*tempd7 + tempd3 - (za-zc)*tempd1
      ydd = ydd + tempd3 - (xa-xc)*tempd7 + (za-zc)*tempd1
      ypd = ypd + tempd2
      zpd = zpd + tempd5
    end subroutine volpym_b
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,
!         whose coordinates are set in the subroutine metric itself,
!         is the top node and a-b-c-d is the quadrilateral surface.
!         it is assumed that the cross product vca * vdb points in
!         the direction of the top node. here vca is the diagonal
!         running from node c to node a and vdb the diagonal from
!         node d to node b.
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block_b
!  differentiation of metric_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *x *si *sj *sk
!   with respect to varying inputs: *x *si *sj *sk
!   rw status of diff variables: *x:incr *si:in-out *sj:in-out
!                *sk:in-out
!   plus diff mem management of: x:in si:in sj:in sk:in
  subroutine metric_block_b()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    real(kind=realtype), dimension(3) :: v1d, v2d
    intrinsic mod
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
    else
      fact = -half
    end if
    call pushreal8array(v1, 3)
    call pushreal8array(v2, 3)
!
!  computation of the face normals in i-, j- and k-direction.
!  formula's are valid for a right handed block; for a left
!  handed block the correct orientation is obtained via fact.
!  the normals point in the direction of increasing index.
!  the absolute value of fact is 0.5, because the cross
!  product of the two diagonals is twice the normal vector.
!  note that also the normals of the first level halo cells
!  are computed. these are needed for the viscous fluxes.
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8array(v1, 3)
    call pushreal8array(v2, 3)
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8array(v1, 3)
    call pushreal8array(v2, 3)
    call pushinteger4(l)
    call pushinteger4(m)
    v1d = 0.0_8
    v2d = 0.0_8
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      tempd5 = fact*skd(i, j, k, 3)
      v1d(1) = v1d(1) + v2(2)*tempd5
      v2d(2) = v2d(2) + v1(1)*tempd5
      v1d(2) = v1d(2) - v2(1)*tempd5
      skd(i, j, k, 3) = 0.0_8
      tempd6 = fact*skd(i, j, k, 2)
      v2d(1) = v2d(1) + v1(3)*tempd6 - v1(2)*tempd5
      v1d(3) = v1d(3) + v2(1)*tempd6
      v1d(1) = v1d(1) - v2(3)*tempd6
      skd(i, j, k, 2) = 0.0_8
      tempd7 = fact*skd(i, j, k, 1)
      v2d(3) = v2d(3) + v1(2)*tempd7 - v1(1)*tempd6
      v1d(2) = v1d(2) + v2(3)*tempd7
      v1d(3) = v1d(3) - v2(2)*tempd7
      v2d(2) = v2d(2) - v1(3)*tempd7
      skd(i, j, k, 1) = 0.0_8
      xd(l, j, k, 3) = xd(l, j, k, 3) + v2d(3)
      xd(i, m, k, 3) = xd(i, m, k, 3) - v2d(3)
      v2d(3) = 0.0_8
      xd(l, j, k, 2) = xd(l, j, k, 2) + v2d(2)
      xd(i, m, k, 2) = xd(i, m, k, 2) - v2d(2)
      v2d(2) = 0.0_8
      xd(l, j, k, 1) = xd(l, j, k, 1) + v2d(1)
      xd(i, m, k, 1) = xd(i, m, k, 1) - v2d(1)
      v2d(1) = 0.0_8
      xd(i, j, k, 3) = xd(i, j, k, 3) + v1d(3)
      xd(l, m, k, 3) = xd(l, m, k, 3) - v1d(3)
      v1d(3) = 0.0_8
      xd(i, j, k, 2) = xd(i, j, k, 2) + v1d(2)
      xd(l, m, k, 2) = xd(l, m, k, 2) - v1d(2)
      v1d(2) = 0.0_8
      xd(i, j, k, 1) = xd(i, j, k, 1) + v1d(1)
      xd(l, m, k, 1) = xd(l, m, k, 1) - v1d(1)
      v1d(1) = 0.0_8
    end do
    call popinteger4(m)
    call popinteger4(l)
    call popreal8array(v2, 3)
    call popreal8array(v1, 3)
    call popinteger4(j)
    call popinteger4(i)
    call lookreal8array(v2, 3)
    call lookreal8array(v1, 3)
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      tempd2 = fact*sjd(i, j, k, 3)
      v1d(1) = v1d(1) + v2(2)*tempd2
      v2d(2) = v2d(2) + v1(1)*tempd2
      v1d(2) = v1d(2) - v2(1)*tempd2
      sjd(i, j, k, 3) = 0.0_8
      tempd3 = fact*sjd(i, j, k, 2)
      v2d(1) = v2d(1) + v1(3)*tempd3 - v1(2)*tempd2
      v1d(3) = v1d(3) + v2(1)*tempd3
      v1d(1) = v1d(1) - v2(3)*tempd3
      sjd(i, j, k, 2) = 0.0_8
      tempd4 = fact*sjd(i, j, k, 1)
      v2d(3) = v2d(3) + v1(2)*tempd4 - v1(1)*tempd3
      v1d(2) = v1d(2) + v2(3)*tempd4
      v1d(3) = v1d(3) - v2(2)*tempd4
      v2d(2) = v2d(2) - v1(3)*tempd4
      sjd(i, j, k, 1) = 0.0_8
      xd(l, j, n, 3) = xd(l, j, n, 3) + v2d(3)
      xd(i, j, k, 3) = xd(i, j, k, 3) - v2d(3)
      v2d(3) = 0.0_8
      xd(l, j, n, 2) = xd(l, j, n, 2) + v2d(2)
      xd(i, j, k, 2) = xd(i, j, k, 2) - v2d(2)
      v2d(2) = 0.0_8
      xd(l, j, n, 1) = xd(l, j, n, 1) + v2d(1)
      xd(i, j, k, 1) = xd(i, j, k, 1) - v2d(1)
      v2d(1) = 0.0_8
      xd(i, j, n, 3) = xd(i, j, n, 3) + v1d(3)
      xd(l, j, k, 3) = xd(l, j, k, 3) - v1d(3)
      v1d(3) = 0.0_8
      xd(i, j, n, 2) = xd(i, j, n, 2) + v1d(2)
      xd(l, j, k, 2) = xd(l, j, k, 2) - v1d(2)
      v1d(2) = 0.0_8
      xd(i, j, n, 1) = xd(i, j, n, 1) + v1d(1)
      xd(l, j, k, 1) = xd(l, j, k, 1) - v1d(1)
      v1d(1) = 0.0_8
    end do
    call popreal8array(v2, 3)
    call popreal8array(v1, 3)
    call popinteger4(j)
    call popinteger4(i)
    call popreal8array(v2, 3)
    call popreal8array(v1, 3)
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      tempd = fact*sid(i, j, k, 3)
      v1d(1) = v1d(1) + v2(2)*tempd
      v2d(2) = v2d(2) + v1(1)*tempd
      v1d(2) = v1d(2) - v2(1)*tempd
      sid(i, j, k, 3) = 0.0_8
      tempd0 = fact*sid(i, j, k, 2)
      v2d(1) = v2d(1) + v1(3)*tempd0 - v1(2)*tempd
      v1d(3) = v1d(3) + v2(1)*tempd0
      v1d(1) = v1d(1) - v2(3)*tempd0
      sid(i, j, k, 2) = 0.0_8
      tempd1 = fact*sid(i, j, k, 1)
      v2d(3) = v2d(3) + v1(2)*tempd1 - v1(1)*tempd0
      v1d(2) = v1d(2) + v2(3)*tempd1
      v1d(3) = v1d(3) - v2(2)*tempd1
      v2d(2) = v2d(2) - v1(3)*tempd1
      sid(i, j, k, 1) = 0.0_8
      xd(i, j, k, 3) = xd(i, j, k, 3) + v2d(3)
      xd(i, m, n, 3) = xd(i, m, n, 3) - v2d(3)
      v2d(3) = 0.0_8
      xd(i, j, k, 2) = xd(i, j, k, 2) + v2d(2)
      xd(i, m, n, 2) = xd(i, m, n, 2) - v2d(2)
      v2d(2) = 0.0_8
      xd(i, j, k, 1) = xd(i, j, k, 1) + v2d(1)
      xd(i, m, n, 1) = xd(i, m, n, 1) - v2d(1)
      v2d(1) = 0.0_8
      xd(i, j, n, 3) = xd(i, j, n, 3) + v1d(3)
      xd(i, m, k, 3) = xd(i, m, k, 3) - v1d(3)
      v1d(3) = 0.0_8
      xd(i, j, n, 2) = xd(i, j, n, 2) + v1d(2)
      xd(i, m, k, 2) = xd(i, m, k, 2) - v1d(2)
      v1d(2) = 0.0_8
      xd(i, j, n, 1) = xd(i, j, n, 1) + v1d(1)
      xd(i, m, k, 1) = xd(i, m, k, 1) - v1d(1)
      v1d(1) = 0.0_8
    end do
  end subroutine metric_block_b
  subroutine metric_block()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic mod
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
    else
      fact = -half
    end if
!
!  computation of the face normals in i-, j- and k-direction.
!  formula's are valid for a right handed block; for a left
!  handed block the correct orientation is obtained via fact.
!  the normals point in the direction of increasing index.
!  the absolute value of fact is 0.5, because the cross
!  product of the two diagonals is twice the normal vector.
!  note that also the normals of the first level halo cells
!  are computed. these are needed for the viscous fluxes.
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the k direction.
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
  end subroutine metric_block
!  differentiation of boundarynormals in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *si *sj *sk *(*bcdata.norm)
!   with respect to varying inputs: *si *sj *sk *(*bcdata.norm)
!   rw status of diff variables: *si:incr *sj:incr *sk:incr *(*bcdata.norm):in-out
!   plus diff mem management of: si:in sj:in sk:in bcdata:in *bcdata.norm:in
  subroutine boundarynormals_b()
!  the unit normals on the boundary faces. these always point
!  out of the domain, so a multiplication by -1 is needed for
!  the imin, jmin and kmin boundaries.
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: factd
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype) :: xxpd, yypd, zzpd
    intrinsic mod
    intrinsic sqrt
    integer :: branch
    real(kind=realtype) :: tempd
    zzpd = 0.0_8
    yypd = 0.0_8
    xxpd = 0.0_8
    do mm=1,nbocos
      call pushinteger4(i)
      call pushreal8(fact)
      call pushreal8(mult)
      call pushreal8(zzp)
      call pushreal8(yyp)
      call pushreal8(xxp)
      call pushinteger4(mm)
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
        if (fact .gt. zero) fact = mult/fact
! compute the unit normal.
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
      call popinteger4(mm)
      call lookreal8(xxp)
      call lookreal8(yyp)
      call lookreal8(zzp)
      call lookreal8(mult)
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
          call pushcontrol3b(1)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
          call pushcontrol3b(2)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
          call pushcontrol3b(3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
          call pushcontrol3b(4)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
          call pushcontrol3b(5)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
          call pushcontrol3b(6)
        case default
          call pushcontrol3b(0)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
        if (fact .gt. zero) then
          call pushreal8(fact)
          fact = mult/fact
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        factd = zzp*bcdatad(mm)%norm(i, j, 3)
        zzpd = zzpd + fact*bcdatad(mm)%norm(i, j, 3)
        bcdatad(mm)%norm(i, j, 3) = 0.0_8
        factd = factd + yyp*bcdatad(mm)%norm(i, j, 2)
        yypd = yypd + fact*bcdatad(mm)%norm(i, j, 2)
        bcdatad(mm)%norm(i, j, 2) = 0.0_8
        factd = factd + xxp*bcdatad(mm)%norm(i, j, 1)
        xxpd = xxpd + fact*bcdatad(mm)%norm(i, j, 1)
        bcdatad(mm)%norm(i, j, 1) = 0.0_8
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(fact)
          factd = -(mult*factd/fact**2)
        end if
        if (xxp**2 + yyp**2 + zzp**2 .eq. 0.0_8) then
          tempd = 0.0
        else
          tempd = factd/(2.0*sqrt(xxp**2+yyp**2+zzp**2))
        end if
        xxpd = xxpd + 2*xxp*tempd
        yypd = yypd + 2*yyp*tempd
        zzpd = zzpd + 2*zzp*tempd
        call popcontrol3b(branch)
        if (branch .lt. 3) then
          if (branch .ne. 0) then
            if (branch .eq. 1) then
              sid(1, i, j, 3) = sid(1, i, j, 3) + zzpd
              sid(1, i, j, 2) = sid(1, i, j, 2) + yypd
              sid(1, i, j, 1) = sid(1, i, j, 1) + xxpd
              zzpd = 0.0_8
              yypd = 0.0_8
              xxpd = 0.0_8
            else
              sid(il, i, j, 3) = sid(il, i, j, 3) + zzpd
              sid(il, i, j, 2) = sid(il, i, j, 2) + yypd
              sid(il, i, j, 1) = sid(il, i, j, 1) + xxpd
              zzpd = 0.0_8
              yypd = 0.0_8
              xxpd = 0.0_8
            end if
          end if
        else if (branch .lt. 5) then
          if (branch .eq. 3) then
            sjd(i, 1, j, 3) = sjd(i, 1, j, 3) + zzpd
            sjd(i, 1, j, 2) = sjd(i, 1, j, 2) + yypd
            sjd(i, 1, j, 1) = sjd(i, 1, j, 1) + xxpd
            zzpd = 0.0_8
            yypd = 0.0_8
            xxpd = 0.0_8
          else
            sjd(i, jl, j, 3) = sjd(i, jl, j, 3) + zzpd
            sjd(i, jl, j, 2) = sjd(i, jl, j, 2) + yypd
            sjd(i, jl, j, 1) = sjd(i, jl, j, 1) + xxpd
            zzpd = 0.0_8
            yypd = 0.0_8
            xxpd = 0.0_8
          end if
        else if (branch .eq. 5) then
          skd(i, j, 1, 3) = skd(i, j, 1, 3) + zzpd
          skd(i, j, 1, 2) = skd(i, j, 1, 2) + yypd
          skd(i, j, 1, 1) = skd(i, j, 1, 1) + xxpd
          zzpd = 0.0_8
          yypd = 0.0_8
          xxpd = 0.0_8
        else
          skd(i, j, kl, 3) = skd(i, j, kl, 3) + zzpd
          skd(i, j, kl, 2) = skd(i, j, kl, 2) + yypd
          skd(i, j, kl, 1) = skd(i, j, kl, 1) + xxpd
          zzpd = 0.0_8
          yypd = 0.0_8
          xxpd = 0.0_8
        end if
      end do
      call popreal8(xxp)
      call popreal8(yyp)
      call popreal8(zzp)
      call popreal8(mult)
      call popreal8(fact)
      call popinteger4(i)
    end do
  end subroutine boundarynormals_b
  subroutine boundarynormals()
!  the unit normals on the boundary faces. these always point
!  out of the domain, so a multiplication by -1 is needed for
!  the imin, jmin and kmin boundaries.
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xxp, yyp, zzp
    intrinsic mod
    intrinsic sqrt
!loop over the boundary subfaces of this block.
bocoloop:do mm=1,nbocos
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
        if (fact .gt. zero) fact = mult/fact
! compute the unit normal.
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
    end do bocoloop
  end subroutine boundarynormals
!  differentiation of xhalo_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *x
!   with respect to varying inputs: *x
!   rw status of diff variables: *x:in-out
!   plus diff mem management of: x:in
  subroutine xhalo_block_b()
!
!       xhalo determines the coordinates of the nodal halo's.
!       first it sets all halo coordinates by simple extrapolation,
!       then the symmetry planes are treated (also the unit normal of
!       symmetry planes are determined) and finally an exchange is
!       made for the internal halo's.
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype) :: dotd
    real(kind=realtype), dimension(3) :: v1, v2, norm
    real(kind=realtype), dimension(3) :: v1d
    intrinsic sqrt
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmp2
    real(kind=realtype) :: tmp3
    real(kind=realtype) :: tmp4
    real(kind=realtype) :: tmp5
    real(kind=realtype) :: tmp6
    real(kind=realtype) :: tmp7
    real(kind=realtype) :: tmp8
    real(kind=realtype) :: tmp9
    real(kind=realtype) :: tmp10
    real(kind=realtype) :: tmp11
    real(kind=realtype) :: tmp12
    real(kind=realtype) :: tmp13
    real(kind=realtype) :: tmp14
    real(kind=realtype) :: tmp15
    real(kind=realtype) :: tmp16
    integer :: ad_from
    integer :: ad_to
    integer :: ad_from0
    integer :: ad_to0
    integer :: ad_from1
    integer :: ad_to1
    integer :: ad_from2
    integer :: ad_to2
    integer :: ad_from3
    integer :: ad_to3
    integer :: ad_from4
    integer :: ad_to4
    integer :: ad_from5
    integer :: ad_to5
    integer :: ad_from6
    integer :: ad_to6
    integer :: ad_from7
    integer :: ad_to7
    integer :: ad_from8
    integer :: ad_to8
    integer :: ad_from9
    integer :: ad_to9
    integer :: ad_from10
    integer :: ad_to10
    integer :: branch
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd16
    real(kind=realtype) :: tmpd15
    real(kind=realtype) :: tmpd14
    real(kind=realtype) :: tmpd13
    real(kind=realtype) :: tmpd12
    real(kind=realtype) :: tmpd11
    real(kind=realtype) :: tmpd10
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tmpd9
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tmpd8
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tmpd7
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tmpd6
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tmpd5
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd4
    real(kind=realtype) :: tmpd3
    real(kind=realtype) :: tmpd2
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
!
!           mirror the halo coordinates adjacent to the symmetry
!           planes
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        call pushreal8(norm(1))
        norm(1) = bcdata(mm)%symnorm(1)
        call pushreal8(norm(2))
        norm(2) = bcdata(mm)%symnorm(2)
        call pushreal8(norm(3))
        norm(3) = bcdata(mm)%symnorm(3)
        length = sqrt(norm(1)**2 + norm(2)**2 + norm(3)**2)
! compute the unit normal of the subface.
        call pushreal8(norm(1))
        norm(1) = norm(1)/length
        call pushreal8(norm(2))
        norm(2) = norm(2)/length
        call pushreal8(norm(3))
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from0 = jbeg
            do j=ad_from0,jend
              ad_from = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from0)
            call pushcontrol4b(7)
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from2 = jbeg
            do j=ad_from2,jend
              ad_from1 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from1)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from2)
            call pushcontrol4b(6)
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from4 = jbeg
            do j=ad_from4,jend
              ad_from3 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from3)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from4)
            call pushcontrol4b(5)
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from6 = jbeg
            do j=ad_from6,jend
              ad_from5 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from5)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from6)
            call pushcontrol4b(4)
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from8 = jbeg
            do j=ad_from8,jend
              ad_from7 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from7)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from8)
            call pushcontrol4b(3)
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from10 = jbeg
            do j=ad_from10,jend
              ad_from9 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from9)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from10)
            call pushcontrol4b(2)
          case default
            call pushcontrol4b(8)
          end select
        else
          call pushcontrol4b(1)
        end if
      else
        call pushcontrol4b(0)
      end if
    end do loopbocos
    v1d = 0.0_8
    do 100 mm=nbocos,1,-1
      call popcontrol4b(branch)
      if (branch .lt. 4) then
        if (branch .lt. 2) then
          if (branch .eq. 0) goto 100
        else if (branch .eq. 2) then
          call popinteger4(ad_from10)
          call popinteger4(ad_to10)
          do j=ad_to10,ad_from10,-1
            call popinteger4(ad_from9)
            call popinteger4(ad_to9)
            do i=ad_to9,ad_from9,-1
              tmpd14 = xd(i, j, ke, 3)
              xd(i, j, ke, 3) = 0.0_8
              xd(i, j, nz, 3) = xd(i, j, nz, 3) + tmpd14
              tmpd15 = xd(i, j, ke, 2)
              xd(i, j, ke, 2) = 0.0_8
              xd(i, j, nz, 2) = xd(i, j, nz, 2) + tmpd15
              tmpd16 = xd(i, j, ke, 1)
              dotd = norm(2)*tmpd15 + norm(1)*tmpd16 + norm(3)*tmpd14
              xd(i, j, ke, 1) = 0.0_8
              xd(i, j, nz, 1) = xd(i, j, nz, 1) + tmpd16
              tempd4 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd4
              v1d(2) = v1d(2) + norm(2)*tempd4
              v1d(3) = v1d(3) + norm(3)*tempd4
              xd(i, j, kl, 3) = xd(i, j, kl, 3) + v1d(3)
              xd(i, j, nz, 3) = xd(i, j, nz, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, j, kl, 2) = xd(i, j, kl, 2) + v1d(2)
              xd(i, j, nz, 2) = xd(i, j, nz, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, j, kl, 1) = xd(i, j, kl, 1) + v1d(1)
              xd(i, j, nz, 1) = xd(i, j, nz, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        else
          call popinteger4(ad_from8)
          call popinteger4(ad_to8)
          do j=ad_to8,ad_from8,-1
            call popinteger4(ad_from7)
            call popinteger4(ad_to7)
            do i=ad_to7,ad_from7,-1
              xd(i, j, 2, 3) = xd(i, j, 2, 3) + xd(i, j, 0, 3)
              dotd = norm(3)*xd(i, j, 0, 3)
              xd(i, j, 0, 3) = 0.0_8
              xd(i, j, 2, 2) = xd(i, j, 2, 2) + xd(i, j, 0, 2)
              dotd = dotd + norm(2)*xd(i, j, 0, 2)
              xd(i, j, 0, 2) = 0.0_8
              xd(i, j, 2, 1) = xd(i, j, 2, 1) + xd(i, j, 0, 1)
              dotd = dotd + norm(1)*xd(i, j, 0, 1)
              xd(i, j, 0, 1) = 0.0_8
              tempd3 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd3
              v1d(2) = v1d(2) + norm(2)*tempd3
              v1d(3) = v1d(3) + norm(3)*tempd3
              xd(i, j, 1, 3) = xd(i, j, 1, 3) + v1d(3)
              xd(i, j, 2, 3) = xd(i, j, 2, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, j, 1, 2) = xd(i, j, 1, 2) + v1d(2)
              xd(i, j, 2, 2) = xd(i, j, 2, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, j, 1, 1) = xd(i, j, 1, 1) + v1d(1)
              xd(i, j, 2, 1) = xd(i, j, 2, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        end if
      else if (branch .lt. 6) then
        if (branch .eq. 4) then
          call popinteger4(ad_from6)
          call popinteger4(ad_to6)
          do j=ad_to6,ad_from6,-1
            call popinteger4(ad_from5)
            call popinteger4(ad_to5)
            do i=ad_to5,ad_from5,-1
              tmpd11 = xd(i, je, j, 3)
              xd(i, je, j, 3) = 0.0_8
              xd(i, ny, j, 3) = xd(i, ny, j, 3) + tmpd11
              tmpd12 = xd(i, je, j, 2)
              xd(i, je, j, 2) = 0.0_8
              xd(i, ny, j, 2) = xd(i, ny, j, 2) + tmpd12
              tmpd13 = xd(i, je, j, 1)
              dotd = norm(2)*tmpd12 + norm(1)*tmpd13 + norm(3)*tmpd11
              xd(i, je, j, 1) = 0.0_8
              xd(i, ny, j, 1) = xd(i, ny, j, 1) + tmpd13
              tempd2 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd2
              v1d(2) = v1d(2) + norm(2)*tempd2
              v1d(3) = v1d(3) + norm(3)*tempd2
              xd(i, jl, j, 3) = xd(i, jl, j, 3) + v1d(3)
              xd(i, ny, j, 3) = xd(i, ny, j, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, jl, j, 2) = xd(i, jl, j, 2) + v1d(2)
              xd(i, ny, j, 2) = xd(i, ny, j, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, jl, j, 1) = xd(i, jl, j, 1) + v1d(1)
              xd(i, ny, j, 1) = xd(i, ny, j, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        else
          call popinteger4(ad_from4)
          call popinteger4(ad_to4)
          do j=ad_to4,ad_from4,-1
            call popinteger4(ad_from3)
            call popinteger4(ad_to3)
            do i=ad_to3,ad_from3,-1
              xd(i, 2, j, 3) = xd(i, 2, j, 3) + xd(i, 0, j, 3)
              dotd = norm(3)*xd(i, 0, j, 3)
              xd(i, 0, j, 3) = 0.0_8
              xd(i, 2, j, 2) = xd(i, 2, j, 2) + xd(i, 0, j, 2)
              dotd = dotd + norm(2)*xd(i, 0, j, 2)
              xd(i, 0, j, 2) = 0.0_8
              xd(i, 2, j, 1) = xd(i, 2, j, 1) + xd(i, 0, j, 1)
              dotd = dotd + norm(1)*xd(i, 0, j, 1)
              xd(i, 0, j, 1) = 0.0_8
              tempd1 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd1
              v1d(2) = v1d(2) + norm(2)*tempd1
              v1d(3) = v1d(3) + norm(3)*tempd1
              xd(i, 1, j, 3) = xd(i, 1, j, 3) + v1d(3)
              xd(i, 2, j, 3) = xd(i, 2, j, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, 1, j, 2) = xd(i, 1, j, 2) + v1d(2)
              xd(i, 2, j, 2) = xd(i, 2, j, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, 1, j, 1) = xd(i, 1, j, 1) + v1d(1)
              xd(i, 2, j, 1) = xd(i, 2, j, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        end if
      else if (branch .eq. 6) then
        call popinteger4(ad_from2)
        call popinteger4(ad_to2)
        do j=ad_to2,ad_from2,-1
          call popinteger4(ad_from1)
          call popinteger4(ad_to1)
          do i=ad_to1,ad_from1,-1
            tmpd8 = xd(ie, i, j, 3)
            xd(ie, i, j, 3) = 0.0_8
            xd(nx, i, j, 3) = xd(nx, i, j, 3) + tmpd8
            tmpd9 = xd(ie, i, j, 2)
            xd(ie, i, j, 2) = 0.0_8
            xd(nx, i, j, 2) = xd(nx, i, j, 2) + tmpd9
            tmpd10 = xd(ie, i, j, 1)
            dotd = norm(2)*tmpd9 + norm(1)*tmpd10 + norm(3)*tmpd8
            xd(ie, i, j, 1) = 0.0_8
            xd(nx, i, j, 1) = xd(nx, i, j, 1) + tmpd10
            tempd0 = two*dotd
            v1d(1) = v1d(1) + norm(1)*tempd0
            v1d(2) = v1d(2) + norm(2)*tempd0
            v1d(3) = v1d(3) + norm(3)*tempd0
            xd(il, i, j, 3) = xd(il, i, j, 3) + v1d(3)
            xd(nx, i, j, 3) = xd(nx, i, j, 3) - v1d(3)
            v1d(3) = 0.0_8
            xd(il, i, j, 2) = xd(il, i, j, 2) + v1d(2)
            xd(nx, i, j, 2) = xd(nx, i, j, 2) - v1d(2)
            v1d(2) = 0.0_8
            xd(il, i, j, 1) = xd(il, i, j, 1) + v1d(1)
            xd(nx, i, j, 1) = xd(nx, i, j, 1) - v1d(1)
            v1d(1) = 0.0_8
          end do
        end do
      else if (branch .eq. 7) then
        call popinteger4(ad_from0)
        call popinteger4(ad_to0)
        do j=ad_to0,ad_from0,-1
          call popinteger4(ad_from)
          call popinteger4(ad_to)
          do i=ad_to,ad_from,-1
            xd(2, i, j, 3) = xd(2, i, j, 3) + xd(0, i, j, 3)
            dotd = norm(3)*xd(0, i, j, 3)
            xd(0, i, j, 3) = 0.0_8
            xd(2, i, j, 2) = xd(2, i, j, 2) + xd(0, i, j, 2)
            dotd = dotd + norm(2)*xd(0, i, j, 2)
            xd(0, i, j, 2) = 0.0_8
            xd(2, i, j, 1) = xd(2, i, j, 1) + xd(0, i, j, 1)
            dotd = dotd + norm(1)*xd(0, i, j, 1)
            xd(0, i, j, 1) = 0.0_8
            tempd = two*dotd
            v1d(1) = v1d(1) + norm(1)*tempd
            v1d(2) = v1d(2) + norm(2)*tempd
            v1d(3) = v1d(3) + norm(3)*tempd
            xd(1, i, j, 3) = xd(1, i, j, 3) + v1d(3)
            xd(2, i, j, 3) = xd(2, i, j, 3) - v1d(3)
            v1d(3) = 0.0_8
            xd(1, i, j, 2) = xd(1, i, j, 2) + v1d(2)
            xd(2, i, j, 2) = xd(2, i, j, 2) - v1d(2)
            v1d(2) = 0.0_8
            xd(1, i, j, 1) = xd(1, i, j, 1) + v1d(1)
            xd(2, i, j, 1) = xd(2, i, j, 1) - v1d(1)
            v1d(1) = 0.0_8
          end do
        end do
      end if
      call popreal8(norm(3))
      call popreal8(norm(2))
      call popreal8(norm(1))
      call popreal8(norm(3))
      call popreal8(norm(2))
      call popreal8(norm(1))
 100 continue
    do j=je,0,-1
      do i=ie,0,-1
        tmpd5 = xd(i, j, ke, 3)
        xd(i, j, ke, 3) = 0.0_8
        xd(i, j, kl, 3) = xd(i, j, kl, 3) + two*tmpd5
        xd(i, j, nz, 3) = xd(i, j, nz, 3) - tmpd5
        tmpd6 = xd(i, j, ke, 2)
        xd(i, j, ke, 2) = 0.0_8
        xd(i, j, kl, 2) = xd(i, j, kl, 2) + two*tmpd6
        xd(i, j, nz, 2) = xd(i, j, nz, 2) - tmpd6
        tmpd7 = xd(i, j, ke, 1)
        xd(i, j, ke, 1) = 0.0_8
        xd(i, j, kl, 1) = xd(i, j, kl, 1) + two*tmpd7
        xd(i, j, nz, 1) = xd(i, j, nz, 1) - tmpd7
        xd(i, j, 1, 3) = xd(i, j, 1, 3) + two*xd(i, j, 0, 3)
        xd(i, j, 2, 3) = xd(i, j, 2, 3) - xd(i, j, 0, 3)
        xd(i, j, 0, 3) = 0.0_8
        xd(i, j, 1, 2) = xd(i, j, 1, 2) + two*xd(i, j, 0, 2)
        xd(i, j, 2, 2) = xd(i, j, 2, 2) - xd(i, j, 0, 2)
        xd(i, j, 0, 2) = 0.0_8
        xd(i, j, 1, 1) = xd(i, j, 1, 1) + two*xd(i, j, 0, 1)
        xd(i, j, 2, 1) = xd(i, j, 2, 1) - xd(i, j, 0, 1)
        xd(i, j, 0, 1) = 0.0_8
      end do
    end do
    do k=kl,1,-1
      do i=ie,0,-1
        tmpd2 = xd(i, je, k, 3)
        xd(i, je, k, 3) = 0.0_8
        xd(i, jl, k, 3) = xd(i, jl, k, 3) + two*tmpd2
        xd(i, ny, k, 3) = xd(i, ny, k, 3) - tmpd2
        tmpd3 = xd(i, je, k, 2)
        xd(i, je, k, 2) = 0.0_8
        xd(i, jl, k, 2) = xd(i, jl, k, 2) + two*tmpd3
        xd(i, ny, k, 2) = xd(i, ny, k, 2) - tmpd3
        tmpd4 = xd(i, je, k, 1)
        xd(i, je, k, 1) = 0.0_8
        xd(i, jl, k, 1) = xd(i, jl, k, 1) + two*tmpd4
        xd(i, ny, k, 1) = xd(i, ny, k, 1) - tmpd4
        xd(i, 1, k, 3) = xd(i, 1, k, 3) + two*xd(i, 0, k, 3)
        xd(i, 2, k, 3) = xd(i, 2, k, 3) - xd(i, 0, k, 3)
        xd(i, 0, k, 3) = 0.0_8
        xd(i, 1, k, 2) = xd(i, 1, k, 2) + two*xd(i, 0, k, 2)
        xd(i, 2, k, 2) = xd(i, 2, k, 2) - xd(i, 0, k, 2)
        xd(i, 0, k, 2) = 0.0_8
        xd(i, 1, k, 1) = xd(i, 1, k, 1) + two*xd(i, 0, k, 1)
        xd(i, 2, k, 1) = xd(i, 2, k, 1) - xd(i, 0, k, 1)
        xd(i, 0, k, 1) = 0.0_8
      end do
    end do
    do k=kl,1,-1
      do j=jl,1,-1
        tmpd = xd(ie, j, k, 3)
        xd(ie, j, k, 3) = 0.0_8
        xd(il, j, k, 3) = xd(il, j, k, 3) + two*tmpd
        xd(nx, j, k, 3) = xd(nx, j, k, 3) - tmpd
        tmpd0 = xd(ie, j, k, 2)
        xd(ie, j, k, 2) = 0.0_8
        xd(il, j, k, 2) = xd(il, j, k, 2) + two*tmpd0
        xd(nx, j, k, 2) = xd(nx, j, k, 2) - tmpd0
        tmpd1 = xd(ie, j, k, 1)
        xd(ie, j, k, 1) = 0.0_8
        xd(il, j, k, 1) = xd(il, j, k, 1) + two*tmpd1
        xd(nx, j, k, 1) = xd(nx, j, k, 1) - tmpd1
        xd(1, j, k, 3) = xd(1, j, k, 3) + two*xd(0, j, k, 3)
        xd(2, j, k, 3) = xd(2, j, k, 3) - xd(0, j, k, 3)
        xd(0, j, k, 3) = 0.0_8
        xd(1, j, k, 2) = xd(1, j, k, 2) + two*xd(0, j, k, 2)
        xd(2, j, k, 2) = xd(2, j, k, 2) - xd(0, j, k, 2)
        xd(0, j, k, 2) = 0.0_8
        xd(1, j, k, 1) = xd(1, j, k, 1) + two*xd(0, j, k, 1)
        xd(2, j, k, 1) = xd(2, j, k, 1) - xd(0, j, k, 1)
        xd(0, j, k, 1) = 0.0_8
      end do
    end do
  end subroutine xhalo_block_b
  subroutine xhalo_block()
!
!       xhalo determines the coordinates of the nodal halo's.
!       first it sets all halo coordinates by simple extrapolation,
!       then the symmetry planes are treated (also the unit normal of
!       symmetry planes are determined) and finally an exchange is
!       made for the internal halo's.
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype), dimension(3) :: v1, v2, norm
    intrinsic sqrt
! extrapolation in i-direction.
    do k=1,kl
      do j=1,jl
        x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
        x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
        x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
        x(ie, j, k, 1) = two*x(il, j, k, 1) - x(nx, j, k, 1)
        x(ie, j, k, 2) = two*x(il, j, k, 2) - x(nx, j, k, 2)
        x(ie, j, k, 3) = two*x(il, j, k, 3) - x(nx, j, k, 3)
      end do
    end do
! extrapolation in j-direction.
    do k=1,kl
      do i=0,ie
        x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
        x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
        x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
        x(i, je, k, 1) = two*x(i, jl, k, 1) - x(i, ny, k, 1)
        x(i, je, k, 2) = two*x(i, jl, k, 2) - x(i, ny, k, 2)
        x(i, je, k, 3) = two*x(i, jl, k, 3) - x(i, ny, k, 3)
      end do
    end do
! extrapolation in k-direction.
    do j=0,je
      do i=0,ie
        x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
        x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
        x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
        x(i, j, ke, 1) = two*x(i, j, kl, 1) - x(i, j, nz, 1)
        x(i, j, ke, 2) = two*x(i, j, kl, 2) - x(i, j, nz, 2)
        x(i, j, ke, 3) = two*x(i, j, kl, 3) - x(i, j, nz, 3)
      end do
    end do
!
!           mirror the halo coordinates adjacent to the symmetry
!           planes
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        norm(1) = bcdata(mm)%symnorm(1)
        norm(2) = bcdata(mm)%symnorm(2)
        norm(3) = bcdata(mm)%symnorm(3)
        length = sqrt(norm(1)**2 + norm(2)**2 + norm(3)**2)
! compute the unit normal of the subface.
        norm(1) = norm(1)/length
        norm(2) = norm(2)/length
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(1, i, j, 1) - x(2, i, j, 1)
                v1(2) = x(1, i, j, 2) - x(2, i, j, 2)
                v1(3) = x(1, i, j, 3) - x(2, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(0, i, j, 1) = x(2, i, j, 1) + dot*norm(1)
                x(0, i, j, 2) = x(2, i, j, 2) + dot*norm(2)
                x(0, i, j, 3) = x(2, i, j, 3) + dot*norm(3)
              end do
            end do
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(il, i, j, 1) - x(nx, i, j, 1)
                v1(2) = x(il, i, j, 2) - x(nx, i, j, 2)
                v1(3) = x(il, i, j, 3) - x(nx, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(ie, i, j, 1) = x(nx, i, j, 1) + dot*norm(1)
                x(ie, i, j, 2) = x(nx, i, j, 2) + dot*norm(2)
                x(ie, i, j, 3) = x(nx, i, j, 3) + dot*norm(3)
              end do
            end do
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, 1, j, 1) - x(i, 2, j, 1)
                v1(2) = x(i, 1, j, 2) - x(i, 2, j, 2)
                v1(3) = x(i, 1, j, 3) - x(i, 2, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, 0, j, 1) = x(i, 2, j, 1) + dot*norm(1)
                x(i, 0, j, 2) = x(i, 2, j, 2) + dot*norm(2)
                x(i, 0, j, 3) = x(i, 2, j, 3) + dot*norm(3)
              end do
            end do
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, jl, j, 1) - x(i, ny, j, 1)
                v1(2) = x(i, jl, j, 2) - x(i, ny, j, 2)
                v1(3) = x(i, jl, j, 3) - x(i, ny, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, je, j, 1) = x(i, ny, j, 1) + dot*norm(1)
                x(i, je, j, 2) = x(i, ny, j, 2) + dot*norm(2)
                x(i, je, j, 3) = x(i, ny, j, 3) + dot*norm(3)
              end do
            end do
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, 1, 1) - x(i, j, 2, 1)
                v1(2) = x(i, j, 1, 2) - x(i, j, 2, 2)
                v1(3) = x(i, j, 1, 3) - x(i, j, 2, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, 0, 1) = x(i, j, 2, 1) + dot*norm(1)
                x(i, j, 0, 2) = x(i, j, 2, 2) + dot*norm(2)
                x(i, j, 0, 3) = x(i, j, 2, 3) + dot*norm(3)
              end do
            end do
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, kl, 1) - x(i, j, nz, 1)
                v1(2) = x(i, j, kl, 2) - x(i, j, nz, 2)
                v1(3) = x(i, j, kl, 3) - x(i, j, nz, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, ke, 1) = x(i, j, nz, 1) + dot*norm(1)
                x(i, j, ke, 2) = x(i, j, nz, 2) + dot*norm(2)
                x(i, j, ke, 3) = x(i, j, nz, 3) + dot*norm(3)
              end do
            end do
          end select
        end if
      end if
    end do loopbocos
  end subroutine xhalo_block
!  differentiation of resscale in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw
!   with respect to varying inputs: *dw
!   rw status of diff variables: *dw:in-out
!   plus diff mem management of: dw:in
  subroutine resscale_b()
    use constants
    use blockpointers, only : il, jl, kl, nx, ny, nz, volref, dw, dwd
    use flowvarrefstate, only : nwf, nt1, nt2
    use inputiteration, only : turbresscale
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii, nturb
    real(kind=realtype) :: ovol
    intrinsic mod
! divide through by the reference volume
    nturb = nt2 - nt1 + 1
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      ovol = one/volref(i, j, k)
      dwd(i, j, k, nt1:nt2) = ovol*turbresscale(1:nturb)*dwd(i, j, k, &
&       nt1:nt2)
      dwd(i, j, k, 1:nwf) = ovol*dwd(i, j, k, 1:nwf)
    end do
  end subroutine resscale_b
  subroutine resscale()
    use constants
    use blockpointers, only : il, jl, kl, nx, ny, nz, volref, dw
    use flowvarrefstate, only : nwf, nt1, nt2
    use inputiteration, only : turbresscale
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii, nturb
    real(kind=realtype) :: ovol
    intrinsic mod
! divide through by the reference volume
    nturb = nt2 - nt1 + 1
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      ovol = one/volref(i, j, k)
      dw(i, j, k, 1:nwf) = dw(i, j, k, 1:nwf)*ovol
      dw(i, j, k, nt1:nt2) = dw(i, j, k, nt1:nt2)*ovol*turbresscale(1:&
&       nturb)
    end do
  end subroutine resscale
!  differentiation of sumdwandfw in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw
!   with respect to varying inputs: *dw *fw
!   rw status of diff variables: *dw:in-out *fw:out
!   plus diff mem management of: dw:in fw:in
  subroutine sumdwandfw_b()
    use constants
    use blockpointers, only : il, jl, kl, dw, dwd, fw, fwd, iblank
    use flowvarrefstate, only : nwf
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, l
    intrinsic real
    intrinsic max
    integer :: branch
    real(kind=realtype) :: x1
    real(kind=realtype) :: max1
    do l=1,nwf
      do k=2,kl
        do j=2,jl
          do i=2,il
            x1 = real(iblank(i, j, k), realtype)
            if (x1 .lt. zero) then
              call pushreal8(max1)
              max1 = zero
              call pushcontrol1b(0)
            else
              call pushreal8(max1)
              max1 = x1
              call pushcontrol1b(1)
            end if
          end do
        end do
      end do
    end do
    fwd = 0.0_8
    do l=nwf,1,-1
      do k=kl,2,-1
        do j=jl,2,-1
          do i=il,2,-1
            fwd(i, j, k, l) = fwd(i, j, k, l) + max1*dwd(i, j, k, l)
            dwd(i, j, k, l) = max1*dwd(i, j, k, l)
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(max1)
            else
              call popreal8(max1)
            end if
          end do
        end do
      end do
    end do
  end subroutine sumdwandfw_b
  subroutine sumdwandfw()
    use constants
    use blockpointers, only : il, jl, kl, dw, fw, iblank
    use flowvarrefstate, only : nwf
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, l
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    real(kind=realtype) :: max1
    do l=1,nwf
      do k=2,kl
        do j=2,jl
          do i=2,il
            x1 = real(iblank(i, j, k), realtype)
            if (x1 .lt. zero) then
              max1 = zero
            else
              max1 = x1
            end if
            dw(i, j, k, l) = (dw(i, j, k, l)+fw(i, j, k, l))*max1
          end do
        end do
      end do
    end do
  end subroutine sumdwandfw

  subroutine gridvelocitiesfinelevel_block_b(useoldcoor, t, sps)
!
!       gridvelocitiesfinelevel computes the grid velocities for
!       the cell centers and the normal grid velocities for the faces
!       of moving blocks for the currently finest grid, i.e.
!       groundlevel. the velocities are computed at time t for
!       spectral mode sps. if useoldcoor is .true. the velocities
!       are determined using the unsteady time integrator in
!       combination with the old coordinates; otherwise the analytic
!       form is used.
!
    use blockpointers
    use cgnsgrid
    use flowvarrefstate
    use inputmotion
    use inputunsteady
    use iteration
    use inputphysics
    use inputtsstabderiv
    use monitor
! gives myid and adflow_comm_world
    use communication
    use flowutils_b, only : derivativerotmatrixrigid, &
&   derivativerotmatrixrigid_b, getdirvector, getdirvector_b
    use utils_b, only : setcoeftimeintegrator, tsalpha, tsbeta, tsmach, &
&   terminate, rotmatrixrigidbody, getdirangle
    implicit none
! mham: remove the nested pointer loop 
!    enddo
! enddo
! mham: remember to close the fake double loop
! enddo fakenestedloop
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: useoldcoor
    real(kind=realtype), dimension(*), intent(in) :: t
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm
    integer(kind=inttype) :: i, j, k, ii, iie, jje, kke, ii_
    real(kind=realtype) :: oneover4dt, oneover8dt
    real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
    real(kind=realtype) :: velxgridd, velygridd, velzgridd, ainfd
    real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
    real(kind=realtype) :: velxgrid0d, velygrid0d, velzgrid0d
    real(kind=realtype), dimension(3) :: sc, xc, xxc
    real(kind=realtype), dimension(3) :: scd, xcd, xxcd
    real(kind=realtype), dimension(3) :: rotcenter, rotrate
    real(kind=realtype), dimension(3) :: rotrated
    real(kind=realtype), dimension(3) :: rotationpoint
    real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
&   derivrotationmatrix
    real(kind=realtype), dimension(3, 3) :: derivrotationmatrixd
    real(kind=realtype) :: tnew, told
! mham: removing pointers for tapenade
! real(kind=realtype), dimension(:,:), pointer :: sface
! sface points to e.g. sface => sfacei(i,:,:). sface has the
! shape: sfacei(0:ie,je,ke) (see l. 617 in initializeflow.f90)
! fake pointer
    real(kind=realtype) :: sface_jk
    real(kind=realtype) :: sface_jkd
! mham: removing pointers for tapenade
! real(kind=realtype), dimension(:,:,:),   pointer :: xx, ss
! fake pointer
    real(kind=realtype) :: xx_x, xx_y, xx_z
    real(kind=realtype) :: xx_xd, xx_yd, xx_zd
    real(kind=realtype) :: xx_x_jk_10, xx_y_jk_10, xx_z_jk_10, &
&   xx_x_jk_01, xx_y_jk_01, xx_z_jk_01, xx_x_jk_11, xx_y_jk_11, &
&   xx_z_jk_11
    real(kind=realtype) :: xx_x_jk_10d, xx_y_jk_10d, xx_z_jk_10d, &
&   xx_x_jk_01d, xx_y_jk_01d, xx_z_jk_01d, xx_x_jk_11d, xx_y_jk_11d, &
&   xx_z_jk_11d
! fake pointer
    real(kind=realtype) :: ss_x, ss_y, ss_z
    real(kind=realtype) :: ss_xd, ss_yd, ss_zd
! only used when useoldcoor==.true.
! real(kind=realtype), dimension(:,:,:,:), pointer :: xxold
    real(kind=realtype) :: intervalmach, alphats, alphaincrement, betats&
&   , betaincrement
    real(kind=realtype), dimension(3) :: veldir
    real(kind=realtype), dimension(3) :: refdirection
    intrinsic sqrt
    intrinsic mod
    integer :: branch
    integer :: ad_to
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! compute the mesh velocity from the given mesh mach number.
! vel{x,y,z}grid0 is the actual velocity you want at the
! geometry.
    ainf = sqrt(gammainf*pinf/rhoinf)
    velxgrid0 = ainf*machgrid*(-veldirfreestream(1))
    velygrid0 = ainf*machgrid*(-veldirfreestream(2))
    velzgrid0 = ainf*machgrid*(-veldirfreestream(3))
! compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. it is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
    call derivativerotmatrixrigid(derivrotationmatrix, rotationpoint, t(&
&                           1))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
    if (tsstability) then
! determine the time values of the old and new time level.
! it is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
      tnew = timeunsteady + timeunsteadyrestart
      told = tnew - t(1)
      if ((tspmode .or. tsqmode) .or. tsrmode) then
! compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
        call rotmatrixrigidbody(tnew, told, rotationmatrix, &
&                         rotationpoint)
        if (tsalphafollowing) then
          velxgrid0 = rotationmatrix(1, 1)*velxgrid0 + rotationmatrix(1&
&           , 2)*velygrid0 + rotationmatrix(1, 3)*velzgrid0
          velygrid0 = rotationmatrix(2, 1)*velxgrid0 + rotationmatrix(2&
&           , 2)*velygrid0 + rotationmatrix(2, 3)*velzgrid0
          velzgrid0 = rotationmatrix(3, 1)*velxgrid0 + rotationmatrix(3&
&           , 2)*velygrid0 + rotationmatrix(3, 3)*velzgrid0
          call pushcontrol3b(0)
        else
          call pushcontrol3b(1)
        end if
      else if (tsalphamode) then
!determine the alpha for this time instance
        alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
&         degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        alphats = alpha + alphaincrement
!determine the grid velocity for this alpha
        refdirection(:) = zero
        refdirection(1) = one
        call getdirvector(refdirection, alphats, beta, veldir, liftindex&
&                  )
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
        velxgrid0 = ainf*machgrid*(-veldir(1))
        velygrid0 = ainf*machgrid*(-veldir(2))
        velzgrid0 = ainf*machgrid*(-veldir(3))
        call pushcontrol3b(2)
      else if (tsbetamode) then
!determine the alpha for this time instance
        betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
&         degreefourbeta, omegafourbeta, coscoeffourbeta, &
&         sincoeffourbeta, t(1))
        betats = beta + betaincrement
!determine the grid velocity for this alpha
        refdirection(:) = zero
        refdirection(1) = one
        call getdirvector(refdirection, alpha, betats, veldir, liftindex&
&                  )
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
        velxgrid0 = ainf*machgrid*(-veldir(1))
        velygrid0 = ainf*machgrid*(-veldir(2))
        velzgrid0 = ainf*machgrid*(-veldir(3))
        call pushcontrol3b(3)
      else if (tsmachmode) then
!determine the mach number at this time interval
        intervalmach = tsmach(degreepolmach, coefpolmach, degreefourmach&
&         , omegafourmach, coscoeffourmach, sincoeffourmach, t(1))
!set the effective grid velocity
        velxgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(1))
        velygrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(2))
        velzgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(3))
        call pushcontrol3b(4)
      else
        call pushcontrol3b(5)
      end if
    else
      call pushcontrol3b(6)
    end if
    if (blockismoving) then
! determine the situation we are having here.
      if (useoldcoor) then
        velxgrid0d = 0.0_8
        velzgrid0d = 0.0_8
        derivrotationmatrixd = 0.0_8
        velygrid0d = 0.0_8
      else
! nothing here... we call the rotational functions with the
! flag send to useoldcoor=.false.
!
! obs! this should of course be improved!
!
!
!             the velocities must be determined analytically.
!
! store the rotation center and determine the
! nondimensional rotation rate of this block. as the
! reference length is 1 timeref == 1/uref and at the end
! the nondimensional velocity is computed.
        j = nbkglobal
        rotcenter = cgnsdoms(j)%rotcenter
        rotrate = timeref*cgnsdoms(j)%rotrate
        velxgrid = velxgrid0
        velygrid = velygrid0
        velzgrid = velzgrid0
!
!             grid velocities of the cell centers, including the
!             1st level halo cells.
!
! loop over the cells, including the 1st level halo's.
        do k=1,ke
          call pushinteger4(j)
          do j=1,je
            do i=1,ie
! determine the coordinates of the cell center,
! which are stored in xc.
              xc(1) = eighth*(x(i-1, j-1, k-1, 1)+x(i, j-1, k-1, 1)+x(i-&
&               1, j, k-1, 1)+x(i, j, k-1, 1)+x(i-1, j-1, k, 1)+x(i, j-1&
&               , k, 1)+x(i-1, j, k, 1)+x(i, j, k, 1))
              xc(2) = eighth*(x(i-1, j-1, k-1, 2)+x(i, j-1, k-1, 2)+x(i-&
&               1, j, k-1, 2)+x(i, j, k-1, 2)+x(i-1, j-1, k, 2)+x(i, j-1&
&               , k, 2)+x(i-1, j, k, 2)+x(i, j, k, 2))
              xc(3) = eighth*(x(i-1, j-1, k-1, 3)+x(i, j-1, k-1, 3)+x(i-&
&               1, j, k-1, 3)+x(i, j, k-1, 3)+x(i-1, j-1, k, 3)+x(i, j-1&
&               , k, 3)+x(i-1, j, k, 3)+x(i, j, k, 3))
! determine the coordinates relative to the
! center of rotation.
              call pushreal8(xxc(1))
              xxc(1) = xc(1) - rotcenter(1)
              call pushreal8(xxc(2))
              xxc(2) = xc(2) - rotcenter(2)
              call pushreal8(xxc(3))
              xxc(3) = xc(3) - rotcenter(3)
! determine the rotation speed of the cell center,
! which is omega*r.
              sc(1) = rotrate(2)*xxc(3) - rotrate(3)*xxc(2)
              sc(2) = rotrate(3)*xxc(1) - rotrate(1)*xxc(3)
              sc(3) = rotrate(1)*xxc(2) - rotrate(2)*xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
              call pushreal8(xxc(1))
              xxc(1) = xc(1) - rotationpoint(1)
              call pushreal8(xxc(2))
              xxc(2) = xc(2) - rotationpoint(2)
              call pushreal8(xxc(3))
              xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell center.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
            end do
          end do
        end do
!
!             normal grid velocities of the faces.
!
! loop over the three directions.
loopdirection:do mm=1,3
! set the upper boundaries depending on the direction.
          select case  (mm) 
          case (1_inttype) 
! normals in i-direction
            iie = ie
            jje = je
            kke = ke
          case (2_inttype) 
! normals in j-direction
            iie = je
            jje = ie
            kke = ke
          case (3_inttype) 
! normals in k-direction
            iie = ke
            jje = ie
            kke = je
          end select
!
!               normal grid velocities in generalized i-direction.
!               mm == 1: i-direction
!               mm == 2: j-direction
!               mm == 3: k-direction
!
! mham: here we insert the the fake double loop
! to avoid use of pointers
! mham: removing old code ->
! do i=0,iie
! set the pointers for the coordinates, normals and
! normal velocities for this generalized i-plane.
! this depends on the value of mm.
! mham: inserting new code ->
fakepointerloop:do ii=0,(iie+1)*kke*jje-1
! outer loop                  
! 0:iie ! 
            call pushinteger4(i)
            i = ii/(jje*kke) + 0
! middle loop                      
! 1:kke ! 
            call pushinteger4(k)
            k = mod(ii/jje, kke) + 1
! inner loop                       
! 1:jje ! 
            call pushinteger4(j)
            j = mod(ii, jje) + 1
! sface => sfacek(:,:,i)
            select case  (mm) 
            case (1_inttype) 
! mham: take a look at the indices below. all 'i' and 'j'
! indices for x(:,:,:,:) have been moved one back, i.e. we
! have added a minus 1. why? because before (in the original
! code) the pointers did not inheret the bounds of the target
! array. this means that for x(:,:,:,:) which has lower
! bound of 0 the pointer to x, i.e. xx would have lower
! bound of 1. now, in the present code we do not use pointers
! so we still have lower bound of 0. we therefore shift the
! 'i' and 'j' (which we designed for pointers) one down to
! acces the right data.
!
! we do not just shift the entire 'i' and 'j' indices since
! they are also used for (fake) si, sj and sk pointers and
! here we know from preprocessing/preprocessingapi.f90:
!    allocate(flowdoms(nn,level,sps)%si(0:ie,1:je,1:ke,3),
! that si(:,:,:,:) for example does not start from 0 for 'i'
! and 'j' but it starts from 1...
! normals in i-direction
! xx =>  x(i,:,:,:)
! mham: for xx we note that it is allocated in
!       partitioning.f90 around l. 1758:
! allocate(flowdoms(nn,1,mm)%x(0:ie,0:je,0:ke,3), stat=ierr)
!       clearly, it is the last index that refers to dim.
              xx_x = x(i, j-1, k-1, 1)
              xx_y = x(i, j-1, k-1, 2)
              xx_z = x(i, j-1, k-1, 3)
! j+=1,k+=0
              xx_x_jk_10 = x(i, j+1-1, k-1, 1)
              xx_y_jk_10 = x(i, j+1-1, k-1, 2)
              xx_z_jk_10 = x(i, j+1-1, k-1, 3)
! j+=0,k+=1
              xx_x_jk_01 = x(i, j-1, k+1-1, 1)
              xx_y_jk_01 = x(i, j-1, k+1-1, 2)
              xx_z_jk_01 = x(i, j-1, k+1-1, 3)
! j+=1,k+=1
              xx_x_jk_11 = x(i, j+1-1, k+1-1, 1)
              xx_y_jk_11 = x(i, j+1-1, k+1-1, 2)
              xx_z_jk_11 = x(i, j+1-1, k+1-1, 3)
! ss => si(i,:,:,:);
              call pushreal8(ss_x)
              ss_x = si(i, j, k, 1)
              call pushreal8(ss_y)
              ss_y = si(i, j, k, 2)
              call pushreal8(ss_z)
              ss_z = si(i, j, k, 3)
              call pushcontrol2b(1)
            case (2_inttype) 
! mham: we do not make fake pointers to the sfacei/j/k
!       since they are not used in the computation.
!       instead, we have a simply container that receives
!       the values from the computation. we then must
!       remember to insert these values in sfacei/j/k
!       that we ideally should have simply pointed to...
! sface => sfacei(i,:,:)
! normals in j-direction
! xx =>  x(:,i,:,:)
              xx_x = x(j-1, i, k-1, 1)
              xx_y = x(j-1, i, k-1, 2)
              xx_z = x(j-1, i, k-1, 3)
! j+=1,k+=0
              xx_x_jk_10 = x(j+1-1, i, k-1, 1)
              xx_y_jk_10 = x(j+1-1, i, k-1, 2)
              xx_z_jk_10 = x(j+1-1, i, k-1, 3)
! j+=0,k+=1
              xx_x_jk_01 = x(j-1, i, k+1-1, 1)
              xx_y_jk_01 = x(j-1, i, k+1-1, 2)
              xx_z_jk_01 = x(j-1, i, k+1-1, 3)
! j+=1,k+=1
              xx_x_jk_11 = x(j+1-1, i, k+1-1, 1)
              xx_y_jk_11 = x(j+1-1, i, k+1-1, 2)
              xx_z_jk_11 = x(j+1-1, i, k+1-1, 3)
! ss => sj(:,i,:,:)
              call pushreal8(ss_x)
              ss_x = sj(j, i, k, 1)
              call pushreal8(ss_y)
              ss_y = sj(j, i, k, 2)
              call pushreal8(ss_z)
              ss_z = sj(j, i, k, 3)
              call pushcontrol2b(2)
            case (3_inttype) 
! sface => sfacej(:,i,:)
! normals in k-direction
! xx =>  x(:,:,i,:)
              xx_x = x(j-1, k-1, i, 1)
              xx_y = x(j-1, k-1, i, 2)
              xx_z = x(j-1, k-1, i, 3)
! j+=1,k+=0
              xx_x_jk_10 = x(j+1-1, k-1, i, 1)
              xx_y_jk_10 = x(j+1-1, k-1, i, 2)
              xx_z_jk_10 = x(j+1-1, k-1, i, 3)
! j+=0,k+=1
              xx_x_jk_01 = x(j-1, k+1-1, i, 1)
              xx_y_jk_01 = x(j-1, k+1-1, i, 2)
              xx_z_jk_01 = x(j-1, k+1-1, i, 3)
! j+=1,k+=1
              xx_x_jk_11 = x(j+1-1, k+1-1, i, 1)
              xx_y_jk_11 = x(j+1-1, k+1-1, i, 2)
              xx_z_jk_11 = x(j+1-1, k+1-1, i, 3)
! ss => sk(:,:,i,:);
              call pushreal8(ss_x)
              ss_x = sk(j, k, i, 1)
              call pushreal8(ss_y)
              ss_y = sk(j, k, i, 2)
              call pushreal8(ss_z)
              ss_z = sk(j, k, i, 3)
              call pushcontrol2b(3)
            case default
              call pushcontrol2b(0)
            end select
! loop over the k and j-direction of this generalized
! i-face. note that due to the usage of the pointer
! xx an offset of +1 must be used in the coordinate
! array, because x originally starts at 0 for the
! i, j and k indices.
! mham: commnet out use of pointer nested loop
! do k=1,kke
!    do j=1,jje
! determine the coordinates of the face center,
! which are stored in xc.
! xc(1) = fourth*(xx(j+1,k+1,1) + xx(j,k+1,1) &
!      +         xx(j+1,k,  1) + xx(j,k,  1))
! xc(2) = fourth*(xx(j+1,k+1,2) + xx(j,k+1,2) &
!      +         xx(j+1,k,  2) + xx(j,k,  2))
! xc(3) = fourth*(xx(j+1,k+1,3) + xx(j,k+1,3) &
!      +         xx(j+1,k,  3) + xx(j,k,  3))
            xc(1) = fourth*(xx_x_jk_11+xx_x_jk_01+xx_x_jk_10+xx_x)
            xc(2) = fourth*(xx_y_jk_11+xx_y_jk_01+xx_y_jk_10+xx_y)
            xc(3) = fourth*(xx_z_jk_11+xx_z_jk_01+xx_z_jk_10+xx_z)
! determine the coordinates relative to the
! center of rotation.
            call pushreal8(xxc(1))
            xxc(1) = xc(1) - rotcenter(1)
            call pushreal8(xxc(2))
            xxc(2) = xc(2) - rotcenter(2)
            call pushreal8(xxc(3))
            xxc(3) = xc(3) - rotcenter(3)
! determine the rotation speed of the face center,
! which is omega*r.
            call pushreal8(sc(1))
            sc(1) = rotrate(2)*xxc(3) - rotrate(3)*xxc(2)
            call pushreal8(sc(2))
            sc(2) = rotrate(3)*xxc(1) - rotrate(1)*xxc(3)
            call pushreal8(sc(3))
            sc(3) = rotrate(1)*xxc(2) - rotrate(2)*xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
            call pushreal8(xxc(1))
            xxc(1) = xc(1) - rotationpoint(1)
            call pushreal8(xxc(2))
            xxc(2) = xc(2) - rotationpoint(2)
            call pushreal8(xxc(3))
            xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell face.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
            call pushreal8(sc(1))
            sc(1) = sc(1) + velxgrid + derivrotationmatrix(1, 1)*xxc(1) &
&             + derivrotationmatrix(1, 2)*xxc(2) + derivrotationmatrix(1&
&             , 3)*xxc(3)
            call pushreal8(sc(2))
            sc(2) = sc(2) + velygrid + derivrotationmatrix(2, 1)*xxc(1) &
&             + derivrotationmatrix(2, 2)*xxc(2) + derivrotationmatrix(2&
&             , 3)*xxc(3)
            call pushreal8(sc(3))
            sc(3) = sc(3) + velzgrid + derivrotationmatrix(3, 1)*xxc(1) &
&             + derivrotationmatrix(3, 2)*xxc(2) + derivrotationmatrix(3&
&             , 3)*xxc(3)
! store the dot product of grid velocity sc and
! the normal ss in sface.
! sface(j,k) = sc(1)*ss(j,k,1) + sc(2)*ss(j,k,2) &
!      + sc(3)*ss(j,k,3)
! mham: we have to remember to manually insert 
!       the sface_jk in the correct container since
!       we removed the pointers...
            select case  (mm) 
            case (1_inttype) 
              call pushcontrol2b(2)
            case (2_inttype) 
              call pushcontrol2b(1)
            case (3_inttype) 
              call pushcontrol2b(0)
            case default
              call pushcontrol2b(3)
            end select
          end do fakepointerloop
          call pushinteger4(ii - 1)
        end do loopdirection
        xx_xd = 0.0_8
        xx_yd = 0.0_8
        xx_zd = 0.0_8
        rotrated = 0.0_8
        velygridd = 0.0_8
        xx_z_jk_01d = 0.0_8
        xcd = 0.0_8
        xx_y_jk_01d = 0.0_8
        xxcd = 0.0_8
        velzgridd = 0.0_8
        ss_xd = 0.0_8
        ss_yd = 0.0_8
        ss_zd = 0.0_8
        xx_z_jk_10d = 0.0_8
        derivrotationmatrixd = 0.0_8
        xx_z_jk_11d = 0.0_8
        xx_x_jk_01d = 0.0_8
        scd = 0.0_8
        xx_y_jk_10d = 0.0_8
        xx_y_jk_11d = 0.0_8
        xx_x_jk_10d = 0.0_8
        xx_x_jk_11d = 0.0_8
        velxgridd = 0.0_8
        do mm=3,1,-1
          call popinteger4(ad_to)
          do ii=ad_to,0,-1
            call popcontrol2b(branch)
            if (branch .lt. 2) then
              if (branch .eq. 0) then
                sface_jkd = sfacekd(j, k, i)
                sfacekd(j, k, i) = 0.0_8
              else
                sface_jkd = sfacejd(j, i, k)
                sfacejd(j, i, k) = 0.0_8
              end if
            else if (branch .eq. 2) then
              sface_jkd = sfaceid(i, j, k)
              sfaceid(i, j, k) = 0.0_8
            else
              sface_jkd = 0.0_8
            end if
            scd(1) = scd(1) + ss_x*sface_jkd
            ss_xd = ss_xd + sc(1)*sface_jkd
            scd(2) = scd(2) + ss_y*sface_jkd
            ss_yd = ss_yd + sc(2)*sface_jkd
            scd(3) = scd(3) + ss_z*sface_jkd
            ss_zd = ss_zd + sc(3)*sface_jkd
            call popreal8(sc(3))
            velzgridd = velzgridd + scd(3)
            derivrotationmatrixd(3, 1) = derivrotationmatrixd(3, 1) + &
&             xxc(1)*scd(3)
            xxcd(1) = xxcd(1) + derivrotationmatrix(3, 1)*scd(3)
            derivrotationmatrixd(3, 2) = derivrotationmatrixd(3, 2) + &
&             xxc(2)*scd(3)
            xxcd(2) = xxcd(2) + derivrotationmatrix(3, 2)*scd(3)
            derivrotationmatrixd(3, 3) = derivrotationmatrixd(3, 3) + &
&             xxc(3)*scd(3)
            xxcd(3) = xxcd(3) + derivrotationmatrix(3, 3)*scd(3)
            call popreal8(sc(2))
            velygridd = velygridd + scd(2)
            derivrotationmatrixd(2, 1) = derivrotationmatrixd(2, 1) + &
&             xxc(1)*scd(2)
            xxcd(1) = xxcd(1) + derivrotationmatrix(2, 1)*scd(2)
            derivrotationmatrixd(2, 2) = derivrotationmatrixd(2, 2) + &
&             xxc(2)*scd(2)
            xxcd(2) = xxcd(2) + derivrotationmatrix(2, 2)*scd(2)
            derivrotationmatrixd(2, 3) = derivrotationmatrixd(2, 3) + &
&             xxc(3)*scd(2)
            xxcd(3) = xxcd(3) + derivrotationmatrix(2, 3)*scd(2)
            call popreal8(sc(1))
            velxgridd = velxgridd + scd(1)
            derivrotationmatrixd(1, 1) = derivrotationmatrixd(1, 1) + &
&             xxc(1)*scd(1)
            xxcd(1) = xxcd(1) + derivrotationmatrix(1, 1)*scd(1)
            derivrotationmatrixd(1, 2) = derivrotationmatrixd(1, 2) + &
&             xxc(2)*scd(1)
            xxcd(2) = xxcd(2) + derivrotationmatrix(1, 2)*scd(1)
            derivrotationmatrixd(1, 3) = derivrotationmatrixd(1, 3) + &
&             xxc(3)*scd(1)
            xxcd(3) = xxcd(3) + derivrotationmatrix(1, 3)*scd(1)
            call popreal8(xxc(3))
            xcd(3) = xcd(3) + xxcd(3)
            xxcd(3) = 0.0_8
            call popreal8(xxc(2))
            xcd(2) = xcd(2) + xxcd(2)
            xxcd(2) = 0.0_8
            call popreal8(xxc(1))
            xcd(1) = xcd(1) + xxcd(1)
            xxcd(1) = 0.0_8
            call popreal8(sc(3))
            rotrated(1) = rotrated(1) + xxc(2)*scd(3)
            xxcd(2) = xxcd(2) + rotrate(1)*scd(3)
            rotrated(2) = rotrated(2) - xxc(1)*scd(3)
            xxcd(1) = xxcd(1) - rotrate(2)*scd(3)
            scd(3) = 0.0_8
            call popreal8(sc(2))
            rotrated(3) = rotrated(3) + xxc(1)*scd(2)
            xxcd(1) = xxcd(1) + rotrate(3)*scd(2)
            rotrated(1) = rotrated(1) - xxc(3)*scd(2)
            xxcd(3) = xxcd(3) - rotrate(1)*scd(2)
            scd(2) = 0.0_8
            call popreal8(sc(1))
            rotrated(2) = rotrated(2) + xxc(3)*scd(1)
            xxcd(3) = xxcd(3) + rotrate(2)*scd(1)
            rotrated(3) = rotrated(3) - xxc(2)*scd(1)
            xxcd(2) = xxcd(2) - rotrate(3)*scd(1)
            scd(1) = 0.0_8
            call popreal8(xxc(3))
            xcd(3) = xcd(3) + xxcd(3)
            xxcd(3) = 0.0_8
            call popreal8(xxc(2))
            xcd(2) = xcd(2) + xxcd(2)
            xxcd(2) = 0.0_8
            call popreal8(xxc(1))
            xcd(1) = xcd(1) + xxcd(1)
            xxcd(1) = 0.0_8
            tempd3 = fourth*xcd(3)
            xx_z_jk_11d = xx_z_jk_11d + tempd3
            xx_z_jk_01d = xx_z_jk_01d + tempd3
            xx_z_jk_10d = xx_z_jk_10d + tempd3
            xx_zd = xx_zd + tempd3
            xcd(3) = 0.0_8
            tempd4 = fourth*xcd(2)
            xx_y_jk_11d = xx_y_jk_11d + tempd4
            xx_y_jk_01d = xx_y_jk_01d + tempd4
            xx_y_jk_10d = xx_y_jk_10d + tempd4
            xx_yd = xx_yd + tempd4
            xcd(2) = 0.0_8
            tempd5 = fourth*xcd(1)
            xx_x_jk_11d = xx_x_jk_11d + tempd5
            xx_x_jk_01d = xx_x_jk_01d + tempd5
            xx_x_jk_10d = xx_x_jk_10d + tempd5
            xx_xd = xx_xd + tempd5
            xcd(1) = 0.0_8
            call popcontrol2b(branch)
            if (branch .lt. 2) then
              if (branch .ne. 0) then
                call popreal8(ss_z)
                sid(i, j, k, 3) = sid(i, j, k, 3) + ss_zd
                call popreal8(ss_y)
                sid(i, j, k, 2) = sid(i, j, k, 2) + ss_yd
                call popreal8(ss_x)
                sid(i, j, k, 1) = sid(i, j, k, 1) + ss_xd
                xd(i, j+1-1, k+1-1, 3) = xd(i, j+1-1, k+1-1, 3) + &
&                 xx_z_jk_11d
                xd(i, j+1-1, k+1-1, 2) = xd(i, j+1-1, k+1-1, 2) + &
&                 xx_y_jk_11d
                xd(i, j+1-1, k+1-1, 1) = xd(i, j+1-1, k+1-1, 1) + &
&                 xx_x_jk_11d
                xd(i, j-1, k+1-1, 3) = xd(i, j-1, k+1-1, 3) + &
&                 xx_z_jk_01d
                xd(i, j-1, k+1-1, 2) = xd(i, j-1, k+1-1, 2) + &
&                 xx_y_jk_01d
                xd(i, j-1, k+1-1, 1) = xd(i, j-1, k+1-1, 1) + &
&                 xx_x_jk_01d
                xd(i, j+1-1, k-1, 3) = xd(i, j+1-1, k-1, 3) + &
&                 xx_z_jk_10d
                xd(i, j+1-1, k-1, 2) = xd(i, j+1-1, k-1, 2) + &
&                 xx_y_jk_10d
                xd(i, j+1-1, k-1, 1) = xd(i, j+1-1, k-1, 1) + &
&                 xx_x_jk_10d
                xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) + xx_zd
                xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) + xx_yd
                xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) + xx_xd
                xx_xd = 0.0_8
                xx_yd = 0.0_8
                xx_zd = 0.0_8
                xx_z_jk_01d = 0.0_8
                xx_y_jk_01d = 0.0_8
                ss_xd = 0.0_8
                ss_yd = 0.0_8
                ss_zd = 0.0_8
                xx_z_jk_10d = 0.0_8
                xx_z_jk_11d = 0.0_8
                xx_x_jk_01d = 0.0_8
                xx_y_jk_10d = 0.0_8
                xx_y_jk_11d = 0.0_8
                xx_x_jk_10d = 0.0_8
                xx_x_jk_11d = 0.0_8
              end if
            else if (branch .eq. 2) then
              call popreal8(ss_z)
              sjd(j, i, k, 3) = sjd(j, i, k, 3) + ss_zd
              call popreal8(ss_y)
              sjd(j, i, k, 2) = sjd(j, i, k, 2) + ss_yd
              call popreal8(ss_x)
              sjd(j, i, k, 1) = sjd(j, i, k, 1) + ss_xd
              xd(j+1-1, i, k+1-1, 3) = xd(j+1-1, i, k+1-1, 3) + &
&               xx_z_jk_11d
              xd(j+1-1, i, k+1-1, 2) = xd(j+1-1, i, k+1-1, 2) + &
&               xx_y_jk_11d
              xd(j+1-1, i, k+1-1, 1) = xd(j+1-1, i, k+1-1, 1) + &
&               xx_x_jk_11d
              xd(j-1, i, k+1-1, 3) = xd(j-1, i, k+1-1, 3) + xx_z_jk_01d
              xd(j-1, i, k+1-1, 2) = xd(j-1, i, k+1-1, 2) + xx_y_jk_01d
              xd(j-1, i, k+1-1, 1) = xd(j-1, i, k+1-1, 1) + xx_x_jk_01d
              xd(j+1-1, i, k-1, 3) = xd(j+1-1, i, k-1, 3) + xx_z_jk_10d
              xd(j+1-1, i, k-1, 2) = xd(j+1-1, i, k-1, 2) + xx_y_jk_10d
              xd(j+1-1, i, k-1, 1) = xd(j+1-1, i, k-1, 1) + xx_x_jk_10d
              xd(j-1, i, k-1, 3) = xd(j-1, i, k-1, 3) + xx_zd
              xd(j-1, i, k-1, 2) = xd(j-1, i, k-1, 2) + xx_yd
              xd(j-1, i, k-1, 1) = xd(j-1, i, k-1, 1) + xx_xd
              xx_xd = 0.0_8
              xx_yd = 0.0_8
              xx_zd = 0.0_8
              xx_z_jk_01d = 0.0_8
              xx_y_jk_01d = 0.0_8
              ss_xd = 0.0_8
              ss_yd = 0.0_8
              ss_zd = 0.0_8
              xx_z_jk_10d = 0.0_8
              xx_z_jk_11d = 0.0_8
              xx_x_jk_01d = 0.0_8
              xx_y_jk_10d = 0.0_8
              xx_y_jk_11d = 0.0_8
              xx_x_jk_10d = 0.0_8
              xx_x_jk_11d = 0.0_8
            else
              call popreal8(ss_z)
              skd(j, k, i, 3) = skd(j, k, i, 3) + ss_zd
              call popreal8(ss_y)
              skd(j, k, i, 2) = skd(j, k, i, 2) + ss_yd
              call popreal8(ss_x)
              skd(j, k, i, 1) = skd(j, k, i, 1) + ss_xd
              xd(j+1-1, k+1-1, i, 3) = xd(j+1-1, k+1-1, i, 3) + &
&               xx_z_jk_11d
              xd(j+1-1, k+1-1, i, 2) = xd(j+1-1, k+1-1, i, 2) + &
&               xx_y_jk_11d
              xd(j+1-1, k+1-1, i, 1) = xd(j+1-1, k+1-1, i, 1) + &
&               xx_x_jk_11d
              xd(j-1, k+1-1, i, 3) = xd(j-1, k+1-1, i, 3) + xx_z_jk_01d
              xd(j-1, k+1-1, i, 2) = xd(j-1, k+1-1, i, 2) + xx_y_jk_01d
              xd(j-1, k+1-1, i, 1) = xd(j-1, k+1-1, i, 1) + xx_x_jk_01d
              xd(j+1-1, k-1, i, 3) = xd(j+1-1, k-1, i, 3) + xx_z_jk_10d
              xd(j+1-1, k-1, i, 2) = xd(j+1-1, k-1, i, 2) + xx_y_jk_10d
              xd(j+1-1, k-1, i, 1) = xd(j+1-1, k-1, i, 1) + xx_x_jk_10d
              xd(j-1, k-1, i, 3) = xd(j-1, k-1, i, 3) + xx_zd
              xd(j-1, k-1, i, 2) = xd(j-1, k-1, i, 2) + xx_yd
              xd(j-1, k-1, i, 1) = xd(j-1, k-1, i, 1) + xx_xd
              xx_xd = 0.0_8
              xx_yd = 0.0_8
              xx_zd = 0.0_8
              xx_z_jk_01d = 0.0_8
              xx_y_jk_01d = 0.0_8
              ss_xd = 0.0_8
              ss_yd = 0.0_8
              ss_zd = 0.0_8
              xx_z_jk_10d = 0.0_8
              xx_z_jk_11d = 0.0_8
              xx_x_jk_01d = 0.0_8
              xx_y_jk_10d = 0.0_8
              xx_y_jk_11d = 0.0_8
              xx_x_jk_10d = 0.0_8
              xx_x_jk_11d = 0.0_8
            end if
            call popinteger4(j)
            call popinteger4(k)
            call popinteger4(i)
          end do
        end do
        do k=ke,1,-1
          do j=je,1,-1
            do i=ie,1,-1
              scd(3) = scd(3) + sd(i, j, k, 3)
              velzgridd = velzgridd + sd(i, j, k, 3)
              derivrotationmatrixd(3, 1) = derivrotationmatrixd(3, 1) + &
&               xxc(1)*sd(i, j, k, 3)
              xxcd(1) = xxcd(1) + derivrotationmatrix(3, 1)*sd(i, j, k, &
&               3)
              derivrotationmatrixd(3, 2) = derivrotationmatrixd(3, 2) + &
&               xxc(2)*sd(i, j, k, 3)
              xxcd(2) = xxcd(2) + derivrotationmatrix(3, 2)*sd(i, j, k, &
&               3)
              derivrotationmatrixd(3, 3) = derivrotationmatrixd(3, 3) + &
&               xxc(3)*sd(i, j, k, 3)
              xxcd(3) = xxcd(3) + derivrotationmatrix(3, 3)*sd(i, j, k, &
&               3)
              sd(i, j, k, 3) = 0.0_8
              scd(2) = scd(2) + sd(i, j, k, 2)
              velygridd = velygridd + sd(i, j, k, 2)
              derivrotationmatrixd(2, 1) = derivrotationmatrixd(2, 1) + &
&               xxc(1)*sd(i, j, k, 2)
              xxcd(1) = xxcd(1) + derivrotationmatrix(2, 1)*sd(i, j, k, &
&               2)
              derivrotationmatrixd(2, 2) = derivrotationmatrixd(2, 2) + &
&               xxc(2)*sd(i, j, k, 2)
              xxcd(2) = xxcd(2) + derivrotationmatrix(2, 2)*sd(i, j, k, &
&               2)
              derivrotationmatrixd(2, 3) = derivrotationmatrixd(2, 3) + &
&               xxc(3)*sd(i, j, k, 2)
              xxcd(3) = xxcd(3) + derivrotationmatrix(2, 3)*sd(i, j, k, &
&               2)
              sd(i, j, k, 2) = 0.0_8
              scd(1) = scd(1) + sd(i, j, k, 1)
              velxgridd = velxgridd + sd(i, j, k, 1)
              derivrotationmatrixd(1, 1) = derivrotationmatrixd(1, 1) + &
&               xxc(1)*sd(i, j, k, 1)
              xxcd(1) = xxcd(1) + derivrotationmatrix(1, 1)*sd(i, j, k, &
&               1)
              derivrotationmatrixd(1, 2) = derivrotationmatrixd(1, 2) + &
&               xxc(2)*sd(i, j, k, 1)
              xxcd(2) = xxcd(2) + derivrotationmatrix(1, 2)*sd(i, j, k, &
&               1)
              derivrotationmatrixd(1, 3) = derivrotationmatrixd(1, 3) + &
&               xxc(3)*sd(i, j, k, 1)
              xxcd(3) = xxcd(3) + derivrotationmatrix(1, 3)*sd(i, j, k, &
&               1)
              sd(i, j, k, 1) = 0.0_8
              call popreal8(xxc(3))
              xcd(3) = xcd(3) + xxcd(3)
              xxcd(3) = 0.0_8
              call popreal8(xxc(2))
              xcd(2) = xcd(2) + xxcd(2)
              xxcd(2) = 0.0_8
              call popreal8(xxc(1))
              xcd(1) = xcd(1) + xxcd(1)
              xxcd(1) = 0.0_8
              rotrated(1) = rotrated(1) + xxc(2)*scd(3)
              xxcd(2) = xxcd(2) + rotrate(1)*scd(3)
              rotrated(2) = rotrated(2) - xxc(1)*scd(3)
              xxcd(1) = xxcd(1) - rotrate(2)*scd(3)
              scd(3) = 0.0_8
              rotrated(3) = rotrated(3) + xxc(1)*scd(2)
              xxcd(1) = xxcd(1) + rotrate(3)*scd(2)
              rotrated(1) = rotrated(1) - xxc(3)*scd(2)
              xxcd(3) = xxcd(3) - rotrate(1)*scd(2)
              scd(2) = 0.0_8
              rotrated(2) = rotrated(2) + xxc(3)*scd(1)
              xxcd(3) = xxcd(3) + rotrate(2)*scd(1)
              rotrated(3) = rotrated(3) - xxc(2)*scd(1)
              xxcd(2) = xxcd(2) - rotrate(3)*scd(1)
              scd(1) = 0.0_8
              call popreal8(xxc(3))
              xcd(3) = xcd(3) + xxcd(3)
              xxcd(3) = 0.0_8
              call popreal8(xxc(2))
              xcd(2) = xcd(2) + xxcd(2)
              xxcd(2) = 0.0_8
              call popreal8(xxc(1))
              xcd(1) = xcd(1) + xxcd(1)
              xxcd(1) = 0.0_8
              tempd0 = eighth*xcd(3)
              xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) + tempd0
              xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) + tempd0
              xd(i-1, j, k-1, 3) = xd(i-1, j, k-1, 3) + tempd0
              xd(i, j, k-1, 3) = xd(i, j, k-1, 3) + tempd0
              xd(i-1, j-1, k, 3) = xd(i-1, j-1, k, 3) + tempd0
              xd(i, j-1, k, 3) = xd(i, j-1, k, 3) + tempd0
              xd(i-1, j, k, 3) = xd(i-1, j, k, 3) + tempd0
              xd(i, j, k, 3) = xd(i, j, k, 3) + tempd0
              xcd(3) = 0.0_8
              tempd1 = eighth*xcd(2)
              xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) + tempd1
              xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) + tempd1
              xd(i-1, j, k-1, 2) = xd(i-1, j, k-1, 2) + tempd1
              xd(i, j, k-1, 2) = xd(i, j, k-1, 2) + tempd1
              xd(i-1, j-1, k, 2) = xd(i-1, j-1, k, 2) + tempd1
              xd(i, j-1, k, 2) = xd(i, j-1, k, 2) + tempd1
              xd(i-1, j, k, 2) = xd(i-1, j, k, 2) + tempd1
              xd(i, j, k, 2) = xd(i, j, k, 2) + tempd1
              xcd(2) = 0.0_8
              tempd2 = eighth*xcd(1)
              xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) + tempd2
              xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) + tempd2
              xd(i-1, j, k-1, 1) = xd(i-1, j, k-1, 1) + tempd2
              xd(i, j, k-1, 1) = xd(i, j, k-1, 1) + tempd2
              xd(i-1, j-1, k, 1) = xd(i-1, j-1, k, 1) + tempd2
              xd(i, j-1, k, 1) = xd(i, j-1, k, 1) + tempd2
              xd(i-1, j, k, 1) = xd(i-1, j, k, 1) + tempd2
              xd(i, j, k, 1) = xd(i, j, k, 1) + tempd2
              xcd(1) = 0.0_8
            end do
          end do
          call popinteger4(j)
        end do
        velzgrid0d = velzgridd
        velygrid0d = velygridd
        velxgrid0d = velxgridd
        timerefd = timerefd + sum(cgnsdoms(j)%rotrate*rotrated)
      end if
    else
      velxgrid0d = 0.0_8
      velzgrid0d = 0.0_8
      derivrotationmatrixd = 0.0_8
      velygrid0d = 0.0_8
    end if
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .eq. 0) then
        velygrid0d = velygrid0d + rotationmatrix(3, 2)*velzgrid0d
        velxgrid0d = velxgrid0d + rotationmatrix(2, 1)*velygrid0d + &
&         rotationmatrix(3, 1)*velzgrid0d
        velzgrid0d = rotationmatrix(2, 3)*velygrid0d + rotationmatrix(1&
&         , 3)*velxgrid0d + rotationmatrix(3, 3)*velzgrid0d
        velygrid0d = rotationmatrix(1, 2)*velxgrid0d + rotationmatrix(2&
&         , 2)*velygrid0d
        velxgrid0d = rotationmatrix(1, 1)*velxgrid0d
      else if (branch .ne. 1) then
        ainfd = -(veldir(2)*machgrid*velygrid0d) - veldir(1)*machgrid*&
&         velxgrid0d - veldir(3)*machgrid*velzgrid0d
        machgridd = machgridd - veldir(2)*ainf*velygrid0d - veldir(1)*&
&         ainf*velxgrid0d - veldir(3)*ainf*velzgrid0d
        velxgrid0d = 0.0_8
        velzgrid0d = 0.0_8
        velygrid0d = 0.0_8
        goto 100
      end if
      ainfd = 0.0_8
    else if (branch .lt. 5) then
      if (branch .eq. 3) then
        ainfd = -(veldir(2)*machgrid*velygrid0d) - veldir(1)*machgrid*&
&         velxgrid0d - veldir(3)*machgrid*velzgrid0d
        machgridd = machgridd - veldir(2)*ainf*velygrid0d - veldir(1)*&
&         ainf*velxgrid0d - veldir(3)*ainf*velzgrid0d
        velxgrid0d = 0.0_8
        velzgrid0d = 0.0_8
        velygrid0d = 0.0_8
      else
        machgridd = machgridd - ainf*veldirfreestream(2)*velygrid0d - &
&         ainf*veldirfreestream(1)*velxgrid0d - ainf*veldirfreestream(3)&
&         *velzgrid0d
        ainfd = -((intervalmach+machgrid)*veldirfreestream(2)*velygrid0d&
&         ) - (intervalmach+machgrid)*veldirfreestream(1)*velxgrid0d - (&
&         intervalmach+machgrid)*veldirfreestream(3)*velzgrid0d
        veldirfreestreamd(3) = veldirfreestreamd(3) - (intervalmach+&
&         machgrid)*ainf*velzgrid0d
        veldirfreestreamd(2) = veldirfreestreamd(2) - (intervalmach+&
&         machgrid)*ainf*velygrid0d
        veldirfreestreamd(1) = veldirfreestreamd(1) - (intervalmach+&
&         machgrid)*ainf*velxgrid0d
        velxgrid0d = 0.0_8
        velzgrid0d = 0.0_8
        velygrid0d = 0.0_8
      end if
    else if (branch .eq. 5) then
      ainfd = 0.0_8
    else
      ainfd = 0.0_8
    end if
 100 call derivativerotmatrixrigid_b(derivrotationmatrix, &
&                              derivrotationmatrixd, rotationpoint, t(1)&
&                             )
    ainfd = ainfd - veldirfreestream(2)*machgrid*velygrid0d - &
&     veldirfreestream(1)*machgrid*velxgrid0d - veldirfreestream(3)*&
&     machgrid*velzgrid0d
    machgridd = machgridd - veldirfreestream(2)*ainf*velygrid0d - &
&     veldirfreestream(1)*ainf*velxgrid0d - veldirfreestream(3)*ainf*&
&     velzgrid0d
    veldirfreestreamd(3) = veldirfreestreamd(3) - ainf*machgrid*&
&     velzgrid0d
    veldirfreestreamd(2) = veldirfreestreamd(2) - ainf*machgrid*&
&     velygrid0d
    veldirfreestreamd(1) = veldirfreestreamd(1) - ainf*machgrid*&
&     velxgrid0d
    temp = gammainf*pinf/rhoinf
    if (temp .eq. 0.0_8) then
      tempd = 0.0
    else
      tempd = ainfd/(2.0*sqrt(temp)*rhoinf)
    end if
    gammainfd = gammainfd + pinf*tempd
    pinfd = pinfd + gammainf*tempd
    rhoinfd = rhoinfd - temp*tempd
  end subroutine gridvelocitiesfinelevel_block_b
! ! mham addition

! !  differentiation of slipvelocitiesfinelevel_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
! !   gradient     of useful results: *(*bcdata.uslip)
! !   with respect to varying inputs: veldirfreestream machgrid gammainf
! !                pinf timeref rhoinf *x *(*bcdata.uslip)
! !   rw status of diff variables: veldirfreestream:out machgrid:out
! !                gammainf:out pinf:out timeref:out rhoinf:out *x:out
! !                *(*bcdata.uslip):in-out
! !   plus diff mem management of: x:in bcdata:in *bcdata.uslip:in
! ! mham addition
!   subroutine slipvelocitiesfinelevel_block_b(useoldcoor, t, sps)
! !
! !       slipvelocitiesfinelevel computes the slip velocities for
! !       viscous subfaces on all viscous boundaries on groundlevel for
! !       the given spectral solution. if useoldcoor is .true. the
! !       velocities are determined using the unsteady time integrator;
! !       otherwise the analytic form is used.
! !
!     use constants
!     use inputtimespectral
!     use blockpointers
!     use cgnsgrid
!     use flowvarrefstate
!     use inputmotion
!     use inputunsteady
!     use iteration
!     use inputphysics
!     use inputtsstabderiv
!     use monitor
!     use communication
!     use flowutils_b, only : derivativerotmatrixrigid, &
! &   derivativerotmatrixrigid_b, getdirvector, getdirvector_b
!     use utils_b, only : tsalpha, tsbeta, tsmach, terminate, &
! &   rotmatrixrigidbody, setcoeftimeintegrator, getdirangle
!     implicit none
! ! mham: these nested loops have been replaced by fakenestedloop2
! !    enddo
! ! enddo
! !
! !      subroutine arguments.
! !
!     integer(kind=inttype), intent(in) :: sps
!     logical, intent(in) :: useoldcoor
!     real(kind=realtype), dimension(*), intent(in) :: t
! !
! !      local variables.
! !
!     integer(kind=inttype) :: nn, mm, i, j, level
!     real(kind=realtype) :: oneover4dt
!     real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
!     real(kind=realtype) :: velxgridd, velygridd, velzgridd, ainfd
!     real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
!     real(kind=realtype) :: velxgrid0d, velygrid0d, velzgrid0d
!     real(kind=realtype), dimension(3) :: xc, xxc
!     real(kind=realtype), dimension(3) :: xcd, xxcd
!     real(kind=realtype), dimension(3) :: rotcenter, rotrate
!     real(kind=realtype), dimension(3) :: rotrated
!     real(kind=realtype), dimension(3) :: rotationpoint
!     real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
! &   derivrotationmatrix
!     real(kind=realtype), dimension(3, 3) :: derivrotationmatrixd
!     real(kind=realtype) :: tnew, told
! ! mham corrections for tapenade use
! ! real(kind=realtype), dimension(:,:,:),   pointer :: uslip
! ! real(kind=realtype), dimension(:,:,:),   pointer :: xface
! ! mham: we do not need xfaceold...
! ! real(kind=realtype), dimension(:,:,:,:), pointer :: xfaceold
! !
! ! l. 2241 in bcdata.f90
! ! bcdata(mm)%uslip(ibeg:iend,jbeg:jend,3)
! ! this one we simply insert below. it is one-to-one. code will be longer
! ! / less readable but effectively unaltered
! !
!     real(kind=realtype) :: xface_x, xface_y, xface_z
!     real(kind=realtype) :: xface_xd, xface_yd, xface_zd
!     real(kind=realtype) :: xface_x_ij_10, xface_y_ij_10, xface_z_ij_10, &
! &   xface_x_ij_01, xface_y_ij_01, xface_z_ij_01, xface_x_ij_11, &
! &   xface_y_ij_11, xface_z_ij_11
!     real(kind=realtype) :: xface_x_ij_10d, xface_y_ij_10d, &
! &   xface_z_ij_10d, xface_x_ij_01d, xface_y_ij_01d, xface_z_ij_01d, &
! &   xface_x_ij_11d, xface_y_ij_11d, xface_z_ij_11d
! ! real(kind=realtype)   :: xfaceold
! ! mham: now, we must remember to declare new counter used in the fake-loop
!     integer :: ii, i_, j_
! !        
!     real(kind=realtype) :: intervalmach, alphats, alphaincrement, betats&
! &   , betaincrement
!     real(kind=realtype), dimension(3) :: veldir
!     real(kind=realtype), dimension(3) :: refdirection
!     intrinsic sqrt
!     integer :: branch
!     integer :: ad_from
!     integer :: ad_to
!     integer :: ad_from0
!     integer :: ad_to0
!     real(kind=realtype) :: tempd
!     real(kind=realtype) :: tempd2
!     real(kind=realtype) :: tempd1
!     real(kind=realtype) :: tempd0
!     real(kind=realtype) :: temp
! ! determine the situation we are having here.
!     if (useoldcoor) then
!       veldirfreestreamd = 0.0_8
!       machgridd = 0.0_8
!       gammainfd = 0.0_8
!       pinfd = 0.0_8
!       timerefd = 0.0_8
!       rhoinfd = 0.0_8
!       xd = 0.0_8
!     else
! ! mham: nothing here, since we set useoldcoor=.false.
! !       everything has been cut out.
! ! the velocities must be determined analytically.
! ! compute the mesh velocity from the given mesh mach number.
! !  ainf = sqrt(gammainf*pinf/rhoinf)
! !  velxgrid = ainf*machgrid(1)
! !  velygrid = ainf*machgrid(2)
! !  velzgrid = ainf*machgrid(3)
!       ainf = sqrt(gammainf*pinf/rhoinf)
! ! compute the derivative of the rotation matrix and the rotation
! ! point; needed for velocity due to the rigid body rotation of
! ! the entire grid. it is assumed that the rigid body motion of
! ! the grid is only specified if there is only 1 section present.
!       call derivativerotmatrixrigid(derivrotationmatrix, rotationpoint, &
! &                             t(1))
! !compute the rotation matrix to update the velocities for the time
! !spectral stability derivative case...
!       if (tsstability) then
! ! determine the time values of the old and new time level.
! ! it is assumed that the rigid body rotation of the mesh is only
! ! used when only 1 section is present.
!         tnew = timeunsteady + timeunsteadyrestart
!         told = tnew - t(1)
!         if ((tspmode .or. tsqmode) .or. tsrmode) then
! ! compute the rotation matrix of the rigid body rotation as
! ! well as the rotation point; the latter may vary in time due
! ! to rigid body translation.
!           call rotmatrixrigidbody(tnew, told, rotationmatrix, &
! &                           rotationpoint)
!           if (tsalphafollowing) then
!             call pushcontrol3b(6)
!           else
!             call pushcontrol3b(5)
!           end if
!         else if (tsalphamode) then
! !determine the alpha for this time instance
!           alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
! &           degreefouralpha, omegafouralpha, coscoeffouralpha, &
! &           sincoeffouralpha, t(1))
!           alphats = alpha + alphaincrement
! !determine the grid velocity for this alpha
!           refdirection(:) = zero
!           refdirection(1) = one
!           call getdirvector(refdirection, alphats, beta, veldir, &
! &                     liftindex)
! !do i need to update the lift direction and drag direction as well?
! !set the effictive grid velocity for this time interval
!           call pushcontrol3b(4)
!         else if (tsbetamode) then
! !determine the alpha for this time instance
!           betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
! &           degreefourbeta, omegafourbeta, coscoeffourbeta, &
! &           sincoeffourbeta, t(1))
!           betats = beta + betaincrement
! !determine the grid velocity for this alpha
!           refdirection(:) = zero
!           refdirection(1) = one
!           call getdirvector(refdirection, alpha, betats, veldir, &
! &                     liftindex)
! !do i need to update the lift direction and drag direction as well?
! !set the effictive grid velocity for this time interval
!           call pushcontrol3b(3)
!         else if (tsmachmode) then
! !determine the mach number at this time interval
!           intervalmach = tsmach(degreepolmach, coefpolmach, &
! &           degreefourmach, omegafourmach, coscoeffourmach, &
! &           sincoeffourmach, t(1))
! !set the effective grid velocity
!           call pushcontrol3b(2)
!         else
!           call pushcontrol3b(1)
!         end if
!       else
!         call pushcontrol3b(0)
!       end if
! ! loop over the number of viscous subfaces.
! bocoloop2:do mm=1,nviscbocos
!         ad_from0 = bcdata(mm)%jcbeg
!         do j=ad_from0,bcdata(mm)%jcend
!           ad_from = bcdata(mm)%icbeg
!           do i=ad_from,bcdata(mm)%icend
! ! determine the grid face on which the subface is located
! ! and set some variables accordingly.
!             select case  (bcfaceid(mm)) 
!             case (imin) 
! ! xface => x(1,:,:,:)
!               xface_x = x(1, i-1, j-1, 1)
!               xface_y = x(1, i-1, j-1, 2)
!               xface_z = x(1, i-1, j-1, 3)
!               xface_x_ij_10 = x(1, i+1-1, j+0-1, 1)
!               xface_y_ij_10 = x(1, i+1-1, j+0-1, 2)
!               xface_z_ij_10 = x(1, i+1-1, j+0-1, 3)
!               xface_x_ij_01 = x(1, i+0-1, j+1-1, 1)
!               xface_y_ij_01 = x(1, i+0-1, j+1-1, 2)
!               xface_z_ij_01 = x(1, i+0-1, j+1-1, 3)
!               xface_x_ij_11 = x(1, i+1-1, j+1-1, 1)
!               xface_y_ij_11 = x(1, i+1-1, j+1-1, 2)
!               xface_z_ij_11 = x(1, i+1-1, j+1-1, 3)
!               call pushcontrol3b(1)
!             case (imax) 
! ! xface => x(il,:,:,:)
!               xface_x = x(il, i-1, j-1, 1)
!               xface_y = x(il, i-1, j-1, 2)
!               xface_z = x(il, i-1, j-1, 3)
!               xface_x_ij_10 = x(il, i+1-1, j+0-1, 1)
!               xface_y_ij_10 = x(il, i+1-1, j+0-1, 2)
!               xface_z_ij_10 = x(il, i+1-1, j+0-1, 3)
!               xface_x_ij_01 = x(il, i+0-1, j+1-1, 1)
!               xface_y_ij_01 = x(il, i+0-1, j+1-1, 2)
!               xface_z_ij_01 = x(il, i+0-1, j+1-1, 3)
!               xface_x_ij_11 = x(il, i+1-1, j+1-1, 1)
!               xface_y_ij_11 = x(il, i+1-1, j+1-1, 2)
!               xface_z_ij_11 = x(il, i+1-1, j+1-1, 3)
!               call pushcontrol3b(2)
!             case (jmin) 
! ! xface => x(:,1,:,:)
!               xface_x = x(i-1, 1, j-1, 1)
!               xface_y = x(i-1, 1, j-1, 2)
!               xface_z = x(i-1, 1, j-1, 3)
!               xface_x_ij_10 = x(i+1-1, 1, j+0-1, 1)
!               xface_y_ij_10 = x(i+1-1, 1, j+0-1, 2)
!               xface_z_ij_10 = x(i+1-1, 1, j+0-1, 3)
!               xface_x_ij_01 = x(i+0-1, 1, j+1-1, 1)
!               xface_y_ij_01 = x(i+0-1, 1, j+1-1, 2)
!               xface_z_ij_01 = x(i+0-1, 1, j+1-1, 3)
!               xface_x_ij_11 = x(i+1-1, 1, j+1-1, 1)
!               xface_y_ij_11 = x(i+1-1, 1, j+1-1, 2)
!               xface_z_ij_11 = x(i+1-1, 1, j+1-1, 3)
!               call pushcontrol3b(3)
!             case (jmax) 
! ! xface => x(:,jl,:,:)
!               xface_x = x(i-1, jl, j-1, 1)
!               xface_y = x(i-1, jl, j-1, 2)
!               xface_z = x(i-1, jl, j-1, 3)
!               xface_x_ij_10 = x(i+1-1, jl, j+0-1, 1)
!               xface_y_ij_10 = x(i+1-1, jl, j+0-1, 2)
!               xface_z_ij_10 = x(i+1-1, jl, j+0-1, 3)
!               xface_x_ij_01 = x(i+0-1, jl, j+1-1, 1)
!               xface_y_ij_01 = x(i+0-1, jl, j+1-1, 2)
!               xface_z_ij_01 = x(i+0-1, jl, j+1-1, 3)
!               xface_x_ij_11 = x(i+1-1, jl, j+1-1, 1)
!               xface_y_ij_11 = x(i+1-1, jl, j+1-1, 2)
!               xface_z_ij_11 = x(i+1-1, jl, j+1-1, 3)
!               call pushcontrol3b(4)
!             case (kmin) 
! ! xface => x(:,:,1,:)
!               xface_x = x(i-1, j-1, 1, 1)
!               xface_y = x(i-1, j-1, 1, 2)
!               xface_z = x(i-1, j-1, 1, 3)
!               xface_x_ij_10 = x(i+1-1, j+0-1, 1, 1)
!               xface_y_ij_10 = x(i+1-1, j+0-1, 1, 2)
!               xface_z_ij_10 = x(i+1-1, j+0-1, 1, 3)
!               xface_x_ij_01 = x(i+0-1, j+1-1, 1, 1)
!               xface_y_ij_01 = x(i+0-1, j+1-1, 1, 2)
!               xface_z_ij_01 = x(i+0-1, j+1-1, 1, 3)
!               xface_x_ij_11 = x(i+1-1, j+1-1, 1, 1)
!               xface_y_ij_11 = x(i+1-1, j+1-1, 1, 2)
!               xface_z_ij_11 = x(i+1-1, j+1-1, 1, 3)
!               call pushcontrol3b(5)
!             case (kmax) 
! ! xface => x(:,:,kl,:)
!               xface_x = x(i-1, j-1, kl, 1)
!               xface_y = x(i-1, j-1, kl, 2)
!               xface_z = x(i-1, j-1, kl, 3)
!               xface_x_ij_10 = x(i+1-1, j+0-1, kl, 1)
!               xface_y_ij_10 = x(i+1-1, j+0-1, kl, 2)
!               xface_z_ij_10 = x(i+1-1, j+0-1, kl, 3)
!               xface_x_ij_01 = x(i+0-1, j+1-1, kl, 1)
!               xface_y_ij_01 = x(i+0-1, j+1-1, kl, 2)
!               xface_z_ij_01 = x(i+0-1, j+1-1, kl, 3)
!               xface_x_ij_11 = x(i+1-1, j+1-1, kl, 1)
!               xface_y_ij_11 = x(i+1-1, j+1-1, kl, 2)
!               xface_z_ij_11 = x(i+1-1, j+1-1, kl, 3)
!               call pushcontrol3b(6)
!             case default
!               call pushcontrol3b(0)
!             end select
! ! store the rotation center and the rotation rate
! ! for this subface.
! ! mham: notice we had to rename these two placeholders, (i,j)->
! ! (i_,j_) since i and j are now inside the i,j-double loop
!             call pushinteger4(i_)
!             i_ = cgnssubface(mm)
!             if (myID == 0) then
!                PRINT*,'A my j_',j_
!             end if
!             rotcenter = cgnsdoms(j_)%bocoinfo(i_)%rotcenter
! ! usewindaxis should go back here!
! ! loop over the quadrilateral faces of the viscous
! ! subface.
! ! mham: this nested loop has been replaced by fakenestedloop2
! ! do j=bcdata(mm)%jcbeg, bcdata(mm)%jcend
! !    do i=bcdata(mm)%icbeg, bcdata(mm)%icend
! ! compute the coordinates of the centroid of the face.
! ! normally this would be an average of i-1 and i, but
! ! due to the usage of the pointer xface and the fact
! ! that x starts at index 0 this is shifted 1 index.
! ! mham: this region is deprecated and has been replaced to
! ! allow for a more smooth tapenade differentiation w.o. any pointers
! ! xc(1) = fourth*(xface(i+1,j+1,1) + xface(i+1,j,1) &
! !      +         xface(i,  j+1,1) + xface(i,  j,1))
! ! xc(2) = fourth*(xface(i+1,j+1,2) + xface(i+1,j,2) &
! !      +         xface(i,  j+1,2) + xface(i,  j,2))
! ! xc(3) = fourth*(xface(i+1,j+1,3) + xface(i+1,j,3) &
! !      +         xface(i,  j+1,3) + xface(i,  j,3))
!             xc(1) = fourth*(xface_x_ij_11+xface_x_ij_10+xface_x_ij_01+&
! &             xface_x)
!             xc(2) = fourth*(xface_y_ij_11+xface_y_ij_10+xface_y_ij_01+&
! &             xface_y)
!             xc(3) = fourth*(xface_z_ij_11+xface_z_ij_10+xface_z_ij_01+&
! &             xface_z)
! ! determine the coordinates relative to the center
! ! of rotation.
!             call pushreal8(xxc(1))
!             xxc(1) = xc(1) - rotcenter(1)
!             call pushreal8(xxc(2))
!             xxc(2) = xc(2) - rotcenter(2)
!             call pushreal8(xxc(3))
!             xxc(3) = xc(3) - rotcenter(3)
! ! compute the velocity, which is the cross product
! ! of rotrate and xc.
! ! determine the coordinates relative to the
! ! rigid body rotation point.
!             call pushreal8(xxc(1))
!             xxc(1) = xc(1) - rotationpoint(1)
!             call pushreal8(xxc(2))
!             xxc(2) = xc(2) - rotationpoint(2)
!             call pushreal8(xxc(3))
!             xxc(3) = xc(3) - rotationpoint(3)
! ! determine the total velocity of the cell center.
! ! this is a combination of rotation speed of this
! ! block and the entire rigid body rotation.
!           end do
!           call pushinteger4(i - 1)
!           call pushinteger4(ad_from)
!         end do
!         call pushinteger4(j - 1)
!         call pushinteger4(ad_from0)
!       end do bocoloop2
!       timerefd = 0.0_8
!       xd = 0.0_8
!       xface_x_ij_10d = 0.0_8
!       xface_x_ij_11d = 0.0_8
!       velxgrid0d = 0.0_8
!       velzgrid0d = 0.0_8
!       xcd = 0.0_8
!       xxcd = 0.0_8
!       xface_z_ij_01d = 0.0_8
!       derivrotationmatrixd = 0.0_8
!       xface_y_ij_01d = 0.0_8
!       velygrid0d = 0.0_8
!       xface_z_ij_10d = 0.0_8
!       xface_z_ij_11d = 0.0_8
!       xface_x_ij_01d = 0.0_8
!       xface_y_ij_10d = 0.0_8
!       xface_y_ij_11d = 0.0_8
!       xface_xd = 0.0_8
!       xface_yd = 0.0_8
!       xface_zd = 0.0_8
!       do mm=nviscbocos,1,-1
!         call popinteger4(ad_from0)
!         call popinteger4(ad_to0)
!         do j=ad_to0,ad_from0,-1
!           call popinteger4(ad_from)
!           call popinteger4(ad_to)
!           do i=ad_to,ad_from,-1
!             velzgridd = bcdatad(mm)%uslip(i, j, 3)
!             derivrotationmatrixd(3, 1) = derivrotationmatrixd(3, 1) + &
! &             xxc(1)*bcdatad(mm)%uslip(i, j, 3)
!             xxcd(1) = xxcd(1) + derivrotationmatrix(3, 1)*bcdatad(mm)%&
! &             uslip(i, j, 3)
!             derivrotationmatrixd(3, 2) = derivrotationmatrixd(3, 2) + &
! &             xxc(2)*bcdatad(mm)%uslip(i, j, 3)
!             xxcd(2) = xxcd(2) + derivrotationmatrix(3, 2)*bcdatad(mm)%&
! &             uslip(i, j, 3)
!             derivrotationmatrixd(3, 3) = derivrotationmatrixd(3, 3) + &
! &             xxc(3)*bcdatad(mm)%uslip(i, j, 3)
!             xxcd(3) = xxcd(3) + derivrotationmatrix(3, 3)*bcdatad(mm)%&
! &             uslip(i, j, 3)
!             velygridd = bcdatad(mm)%uslip(i, j, 2)
!             derivrotationmatrixd(2, 1) = derivrotationmatrixd(2, 1) + &
! &             xxc(1)*bcdatad(mm)%uslip(i, j, 2)
!             xxcd(1) = xxcd(1) + derivrotationmatrix(2, 1)*bcdatad(mm)%&
! &             uslip(i, j, 2)
!             derivrotationmatrixd(2, 2) = derivrotationmatrixd(2, 2) + &
! &             xxc(2)*bcdatad(mm)%uslip(i, j, 2)
!             xxcd(2) = xxcd(2) + derivrotationmatrix(2, 2)*bcdatad(mm)%&
! &             uslip(i, j, 2)
!             derivrotationmatrixd(2, 3) = derivrotationmatrixd(2, 3) + &
! &             xxc(3)*bcdatad(mm)%uslip(i, j, 2)
!             xxcd(3) = xxcd(3) + derivrotationmatrix(2, 3)*bcdatad(mm)%&
! &             uslip(i, j, 2)
!             velxgridd = bcdatad(mm)%uslip(i, j, 1)
!             derivrotationmatrixd(1, 1) = derivrotationmatrixd(1, 1) + &
! &             xxc(1)*bcdatad(mm)%uslip(i, j, 1)
!             xxcd(1) = xxcd(1) + derivrotationmatrix(1, 1)*bcdatad(mm)%&
! &             uslip(i, j, 1)
!             derivrotationmatrixd(1, 2) = derivrotationmatrixd(1, 2) + &
! &             xxc(2)*bcdatad(mm)%uslip(i, j, 1)
!             xxcd(2) = xxcd(2) + derivrotationmatrix(1, 2)*bcdatad(mm)%&
! &             uslip(i, j, 1)
!             derivrotationmatrixd(1, 3) = derivrotationmatrixd(1, 3) + &
! &             xxc(3)*bcdatad(mm)%uslip(i, j, 1)
!             xxcd(3) = xxcd(3) + derivrotationmatrix(1, 3)*bcdatad(mm)%&
! &             uslip(i, j, 1)
!             call popreal8(xxc(3))
!             xcd(3) = xcd(3) + xxcd(3)
!             xxcd(3) = 0.0_8
!             call popreal8(xxc(2))
!             xcd(2) = xcd(2) + xxcd(2)
!             xxcd(2) = 0.0_8
!             call popreal8(xxc(1))
!             xcd(1) = xcd(1) + xxcd(1)
!             xxcd(1) = 0.0_8
!             rotrate = timeref*cgnsdoms(j_)%bocoinfo(i_)%rotrate
!             rotrated = 0.0_8
!             rotrated(1) = rotrated(1) + xxc(2)*bcdatad(mm)%uslip(i, j, 3&
! &             )
!             xxcd(2) = xxcd(2) + rotrate(1)*bcdatad(mm)%uslip(i, j, 3)
!             rotrated(2) = rotrated(2) - xxc(1)*bcdatad(mm)%uslip(i, j, 3&
! &             )
!             xxcd(1) = xxcd(1) - rotrate(2)*bcdatad(mm)%uslip(i, j, 3)
!             bcdatad(mm)%uslip(i, j, 3) = 0.0_8
!             rotrated(3) = rotrated(3) + xxc(1)*bcdatad(mm)%uslip(i, j, 2&
! &             )
!             xxcd(1) = xxcd(1) + rotrate(3)*bcdatad(mm)%uslip(i, j, 2)
!             rotrated(1) = rotrated(1) - xxc(3)*bcdatad(mm)%uslip(i, j, 2&
! &             )
!             xxcd(3) = xxcd(3) - rotrate(1)*bcdatad(mm)%uslip(i, j, 2)
!             bcdatad(mm)%uslip(i, j, 2) = 0.0_8
!             rotrated(2) = rotrated(2) + xxc(3)*bcdatad(mm)%uslip(i, j, 1&
! &             )
!             xxcd(3) = xxcd(3) + rotrate(2)*bcdatad(mm)%uslip(i, j, 1)
!             rotrated(3) = rotrated(3) - xxc(2)*bcdatad(mm)%uslip(i, j, 1&
! &             )
!             xxcd(2) = xxcd(2) - rotrate(3)*bcdatad(mm)%uslip(i, j, 1)
!             bcdatad(mm)%uslip(i, j, 1) = 0.0_8
!             call popreal8(xxc(3))
!             xcd(3) = xcd(3) + xxcd(3)
!             xxcd(3) = 0.0_8
!             call popreal8(xxc(2))
!             xcd(2) = xcd(2) + xxcd(2)
!             xxcd(2) = 0.0_8
!             call popreal8(xxc(1))
!             xcd(1) = xcd(1) + xxcd(1)
!             xxcd(1) = 0.0_8
!             tempd0 = fourth*xcd(3)
!             xface_z_ij_11d = xface_z_ij_11d + tempd0
!             xface_z_ij_10d = xface_z_ij_10d + tempd0
!             xface_z_ij_01d = xface_z_ij_01d + tempd0
!             xface_zd = xface_zd + tempd0
!             xcd(3) = 0.0_8
!             tempd1 = fourth*xcd(2)
!             xface_y_ij_11d = xface_y_ij_11d + tempd1
!             xface_y_ij_10d = xface_y_ij_10d + tempd1
!             xface_y_ij_01d = xface_y_ij_01d + tempd1
!             xface_yd = xface_yd + tempd1
!             xcd(2) = 0.0_8
!             tempd2 = fourth*xcd(1)
!             xface_x_ij_11d = xface_x_ij_11d + tempd2
!             xface_x_ij_10d = xface_x_ij_10d + tempd2
!             xface_x_ij_01d = xface_x_ij_01d + tempd2
!             xface_xd = xface_xd + tempd2
!             xcd(1) = 0.0_8
!             velzgrid0d = velzgrid0d + velzgridd
!             velygrid0d = velygrid0d + velygridd
!             velxgrid0d = velxgrid0d + velxgridd
!             timerefd = timerefd + sum(cgnsdoms(j_)%bocoinfo(i_)%rotrate*&
! &             rotrated)
!             call popinteger4(i_)
!             call popcontrol3b(branch)
!             if (branch .lt. 3) then
!               if (branch .ne. 0) then
!                 if (branch .eq. 1) then
!                   xd(1, i+1-1, j+1-1, 3) = xd(1, i+1-1, j+1-1, 3) + &
! &                   xface_z_ij_11d
!                   xd(1, i+1-1, j+1-1, 2) = xd(1, i+1-1, j+1-1, 2) + &
! &                   xface_y_ij_11d
!                   xd(1, i+1-1, j+1-1, 1) = xd(1, i+1-1, j+1-1, 1) + &
! &                   xface_x_ij_11d
!                   xd(1, i+0-1, j+1-1, 3) = xd(1, i+0-1, j+1-1, 3) + &
! &                   xface_z_ij_01d
!                   xd(1, i+0-1, j+1-1, 2) = xd(1, i+0-1, j+1-1, 2) + &
! &                   xface_y_ij_01d
!                   xd(1, i+0-1, j+1-1, 1) = xd(1, i+0-1, j+1-1, 1) + &
! &                   xface_x_ij_01d
!                   xd(1, i+1-1, j+0-1, 3) = xd(1, i+1-1, j+0-1, 3) + &
! &                   xface_z_ij_10d
!                   xd(1, i+1-1, j+0-1, 2) = xd(1, i+1-1, j+0-1, 2) + &
! &                   xface_y_ij_10d
!                   xd(1, i+1-1, j+0-1, 1) = xd(1, i+1-1, j+0-1, 1) + &
! &                   xface_x_ij_10d
!                   xd(1, i-1, j-1, 3) = xd(1, i-1, j-1, 3) + xface_zd
!                   xd(1, i-1, j-1, 2) = xd(1, i-1, j-1, 2) + xface_yd
!                   xd(1, i-1, j-1, 1) = xd(1, i-1, j-1, 1) + xface_xd
!                   xface_x_ij_10d = 0.0_8
!                   xface_x_ij_11d = 0.0_8
!                   xface_z_ij_01d = 0.0_8
!                   xface_y_ij_01d = 0.0_8
!                   xface_z_ij_10d = 0.0_8
!                   xface_z_ij_11d = 0.0_8
!                   xface_x_ij_01d = 0.0_8
!                   xface_y_ij_10d = 0.0_8
!                   xface_y_ij_11d = 0.0_8
!                   xface_xd = 0.0_8
!                   xface_yd = 0.0_8
!                   xface_zd = 0.0_8
!                 else
!                   xd(il, i+1-1, j+1-1, 3) = xd(il, i+1-1, j+1-1, 3) + &
! &                   xface_z_ij_11d
!                   xd(il, i+1-1, j+1-1, 2) = xd(il, i+1-1, j+1-1, 2) + &
! &                   xface_y_ij_11d
!                   xd(il, i+1-1, j+1-1, 1) = xd(il, i+1-1, j+1-1, 1) + &
! &                   xface_x_ij_11d
!                   xd(il, i+0-1, j+1-1, 3) = xd(il, i+0-1, j+1-1, 3) + &
! &                   xface_z_ij_01d
!                   xd(il, i+0-1, j+1-1, 2) = xd(il, i+0-1, j+1-1, 2) + &
! &                   xface_y_ij_01d
!                   xd(il, i+0-1, j+1-1, 1) = xd(il, i+0-1, j+1-1, 1) + &
! &                   xface_x_ij_01d
!                   xd(il, i+1-1, j+0-1, 3) = xd(il, i+1-1, j+0-1, 3) + &
! &                   xface_z_ij_10d
!                   xd(il, i+1-1, j+0-1, 2) = xd(il, i+1-1, j+0-1, 2) + &
! &                   xface_y_ij_10d
!                   xd(il, i+1-1, j+0-1, 1) = xd(il, i+1-1, j+0-1, 1) + &
! &                   xface_x_ij_10d
!                   xd(il, i-1, j-1, 3) = xd(il, i-1, j-1, 3) + xface_zd
!                   xd(il, i-1, j-1, 2) = xd(il, i-1, j-1, 2) + xface_yd
!                   xd(il, i-1, j-1, 1) = xd(il, i-1, j-1, 1) + xface_xd
!                   xface_x_ij_10d = 0.0_8
!                   xface_x_ij_11d = 0.0_8
!                   xface_z_ij_01d = 0.0_8
!                   xface_y_ij_01d = 0.0_8
!                   xface_z_ij_10d = 0.0_8
!                   xface_z_ij_11d = 0.0_8
!                   xface_x_ij_01d = 0.0_8
!                   xface_y_ij_10d = 0.0_8
!                   xface_y_ij_11d = 0.0_8
!                   xface_xd = 0.0_8
!                   xface_yd = 0.0_8
!                   xface_zd = 0.0_8
!                 end if
!               end if
!             else if (branch .lt. 5) then
!               if (branch .eq. 3) then
!                 xd(i+1-1, 1, j+1-1, 3) = xd(i+1-1, 1, j+1-1, 3) + &
! &                 xface_z_ij_11d
!                 xd(i+1-1, 1, j+1-1, 2) = xd(i+1-1, 1, j+1-1, 2) + &
! &                 xface_y_ij_11d
!                 xd(i+1-1, 1, j+1-1, 1) = xd(i+1-1, 1, j+1-1, 1) + &
! &                 xface_x_ij_11d
!                 xd(i+0-1, 1, j+1-1, 3) = xd(i+0-1, 1, j+1-1, 3) + &
! &                 xface_z_ij_01d
!                 xd(i+0-1, 1, j+1-1, 2) = xd(i+0-1, 1, j+1-1, 2) + &
! &                 xface_y_ij_01d
!                 xd(i+0-1, 1, j+1-1, 1) = xd(i+0-1, 1, j+1-1, 1) + &
! &                 xface_x_ij_01d
!                 xd(i+1-1, 1, j+0-1, 3) = xd(i+1-1, 1, j+0-1, 3) + &
! &                 xface_z_ij_10d
!                 xd(i+1-1, 1, j+0-1, 2) = xd(i+1-1, 1, j+0-1, 2) + &
! &                 xface_y_ij_10d
!                 xd(i+1-1, 1, j+0-1, 1) = xd(i+1-1, 1, j+0-1, 1) + &
! &                 xface_x_ij_10d
!                 xd(i-1, 1, j-1, 3) = xd(i-1, 1, j-1, 3) + xface_zd
!                 xd(i-1, 1, j-1, 2) = xd(i-1, 1, j-1, 2) + xface_yd
!                 xd(i-1, 1, j-1, 1) = xd(i-1, 1, j-1, 1) + xface_xd
!                 xface_x_ij_10d = 0.0_8
!                 xface_x_ij_11d = 0.0_8
!                 xface_z_ij_01d = 0.0_8
!                 xface_y_ij_01d = 0.0_8
!                 xface_z_ij_10d = 0.0_8
!                 xface_z_ij_11d = 0.0_8
!                 xface_x_ij_01d = 0.0_8
!                 xface_y_ij_10d = 0.0_8
!                 xface_y_ij_11d = 0.0_8
!                 xface_xd = 0.0_8
!                 xface_yd = 0.0_8
!                 xface_zd = 0.0_8
!               else
!                 xd(i+1-1, jl, j+1-1, 3) = xd(i+1-1, jl, j+1-1, 3) + &
! &                 xface_z_ij_11d
!                 xd(i+1-1, jl, j+1-1, 2) = xd(i+1-1, jl, j+1-1, 2) + &
! &                 xface_y_ij_11d
!                 xd(i+1-1, jl, j+1-1, 1) = xd(i+1-1, jl, j+1-1, 1) + &
! &                 xface_x_ij_11d
!                 xd(i+0-1, jl, j+1-1, 3) = xd(i+0-1, jl, j+1-1, 3) + &
! &                 xface_z_ij_01d
!                 xd(i+0-1, jl, j+1-1, 2) = xd(i+0-1, jl, j+1-1, 2) + &
! &                 xface_y_ij_01d
!                 xd(i+0-1, jl, j+1-1, 1) = xd(i+0-1, jl, j+1-1, 1) + &
! &                 xface_x_ij_01d
!                 xd(i+1-1, jl, j+0-1, 3) = xd(i+1-1, jl, j+0-1, 3) + &
! &                 xface_z_ij_10d
!                 xd(i+1-1, jl, j+0-1, 2) = xd(i+1-1, jl, j+0-1, 2) + &
! &                 xface_y_ij_10d
!                 xd(i+1-1, jl, j+0-1, 1) = xd(i+1-1, jl, j+0-1, 1) + &
! &                 xface_x_ij_10d
!                 xd(i-1, jl, j-1, 3) = xd(i-1, jl, j-1, 3) + xface_zd
!                 xd(i-1, jl, j-1, 2) = xd(i-1, jl, j-1, 2) + xface_yd
!                 xd(i-1, jl, j-1, 1) = xd(i-1, jl, j-1, 1) + xface_xd
!                 xface_x_ij_10d = 0.0_8
!                 xface_x_ij_11d = 0.0_8
!                 xface_z_ij_01d = 0.0_8
!                 xface_y_ij_01d = 0.0_8
!                 xface_z_ij_10d = 0.0_8
!                 xface_z_ij_11d = 0.0_8
!                 xface_x_ij_01d = 0.0_8
!                 xface_y_ij_10d = 0.0_8
!                 xface_y_ij_11d = 0.0_8
!                 xface_xd = 0.0_8
!                 xface_yd = 0.0_8
!                 xface_zd = 0.0_8
!               end if
!             else if (branch .eq. 5) then
!               xd(i+1-1, j+1-1, 1, 3) = xd(i+1-1, j+1-1, 1, 3) + &
! &               xface_z_ij_11d
!               xd(i+1-1, j+1-1, 1, 2) = xd(i+1-1, j+1-1, 1, 2) + &
! &               xface_y_ij_11d
!               xd(i+1-1, j+1-1, 1, 1) = xd(i+1-1, j+1-1, 1, 1) + &
! &               xface_x_ij_11d
!               xd(i+0-1, j+1-1, 1, 3) = xd(i+0-1, j+1-1, 1, 3) + &
! &               xface_z_ij_01d
!               xd(i+0-1, j+1-1, 1, 2) = xd(i+0-1, j+1-1, 1, 2) + &
! &               xface_y_ij_01d
!               xd(i+0-1, j+1-1, 1, 1) = xd(i+0-1, j+1-1, 1, 1) + &
! &               xface_x_ij_01d
!               xd(i+1-1, j+0-1, 1, 3) = xd(i+1-1, j+0-1, 1, 3) + &
! &               xface_z_ij_10d
!               xd(i+1-1, j+0-1, 1, 2) = xd(i+1-1, j+0-1, 1, 2) + &
! &               xface_y_ij_10d
!               xd(i+1-1, j+0-1, 1, 1) = xd(i+1-1, j+0-1, 1, 1) + &
! &               xface_x_ij_10d
!               xd(i-1, j-1, 1, 3) = xd(i-1, j-1, 1, 3) + xface_zd
!               xd(i-1, j-1, 1, 2) = xd(i-1, j-1, 1, 2) + xface_yd
!               xd(i-1, j-1, 1, 1) = xd(i-1, j-1, 1, 1) + xface_xd
!               xface_x_ij_10d = 0.0_8
!               xface_x_ij_11d = 0.0_8
!               xface_z_ij_01d = 0.0_8
!               xface_y_ij_01d = 0.0_8
!               xface_z_ij_10d = 0.0_8
!               xface_z_ij_11d = 0.0_8
!               xface_x_ij_01d = 0.0_8
!               xface_y_ij_10d = 0.0_8
!               xface_y_ij_11d = 0.0_8
!               xface_xd = 0.0_8
!               xface_yd = 0.0_8
!               xface_zd = 0.0_8
!             else
!               xd(i+1-1, j+1-1, kl, 3) = xd(i+1-1, j+1-1, kl, 3) + &
! &               xface_z_ij_11d
!               xd(i+1-1, j+1-1, kl, 2) = xd(i+1-1, j+1-1, kl, 2) + &
! &               xface_y_ij_11d
!               xd(i+1-1, j+1-1, kl, 1) = xd(i+1-1, j+1-1, kl, 1) + &
! &               xface_x_ij_11d
!               xd(i+0-1, j+1-1, kl, 3) = xd(i+0-1, j+1-1, kl, 3) + &
! &               xface_z_ij_01d
!               xd(i+0-1, j+1-1, kl, 2) = xd(i+0-1, j+1-1, kl, 2) + &
! &               xface_y_ij_01d
!               xd(i+0-1, j+1-1, kl, 1) = xd(i+0-1, j+1-1, kl, 1) + &
! &               xface_x_ij_01d
!               xd(i+1-1, j+0-1, kl, 3) = xd(i+1-1, j+0-1, kl, 3) + &
! &               xface_z_ij_10d
!               xd(i+1-1, j+0-1, kl, 2) = xd(i+1-1, j+0-1, kl, 2) + &
! &               xface_y_ij_10d
!               xd(i+1-1, j+0-1, kl, 1) = xd(i+1-1, j+0-1, kl, 1) + &
! &               xface_x_ij_10d
!               xd(i-1, j-1, kl, 3) = xd(i-1, j-1, kl, 3) + xface_zd
!               xd(i-1, j-1, kl, 2) = xd(i-1, j-1, kl, 2) + xface_yd
!               xd(i-1, j-1, kl, 1) = xd(i-1, j-1, kl, 1) + xface_xd
!               xface_x_ij_10d = 0.0_8
!               xface_x_ij_11d = 0.0_8
!               xface_z_ij_01d = 0.0_8
!               xface_y_ij_01d = 0.0_8
!               xface_z_ij_10d = 0.0_8
!               xface_z_ij_11d = 0.0_8
!               xface_x_ij_01d = 0.0_8
!               xface_y_ij_10d = 0.0_8
!               xface_y_ij_11d = 0.0_8
!               xface_xd = 0.0_8
!               xface_yd = 0.0_8
!               xface_zd = 0.0_8
!             end if
!           end do
!         end do
!       end do
!       call popcontrol3b(branch)
!       if (branch .lt. 3) then
!         if (branch .eq. 0) then
!           veldirfreestreamd = 0.0_8
!           machgridd = 0.0_8
!           ainfd = 0.0_8
!         else if (branch .eq. 1) then
!           veldirfreestreamd = 0.0_8
!           machgridd = 0.0_8
!           ainfd = 0.0_8
!         else
!           veldirfreestreamd = 0.0_8
!           machgridd = -(ainf*veldirfreestream(2)*velygrid0d) - ainf*&
! &           veldirfreestream(1)*velxgrid0d - ainf*veldirfreestream(3)*&
! &           velzgrid0d
!           ainfd = -((intervalmach+machgrid)*veldirfreestream(2)*&
! &           velygrid0d) - (intervalmach+machgrid)*veldirfreestream(1)*&
! &           velxgrid0d - (intervalmach+machgrid)*veldirfreestream(3)*&
! &           velzgrid0d
!           veldirfreestreamd(3) = veldirfreestreamd(3) - (intervalmach+&
! &           machgrid)*ainf*velzgrid0d
!           veldirfreestreamd(2) = veldirfreestreamd(2) - (intervalmach+&
! &           machgrid)*ainf*velygrid0d
!           veldirfreestreamd(1) = veldirfreestreamd(1) - (intervalmach+&
! &           machgrid)*ainf*velxgrid0d
!           velxgrid0d = 0.0_8
!           velzgrid0d = 0.0_8
!           velygrid0d = 0.0_8
!         end if
!       else if (branch .lt. 5) then
!         if (branch .eq. 3) then
!           ainfd = -(veldir(2)*machgrid*velygrid0d) - veldir(1)*machgrid*&
! &           velxgrid0d - veldir(3)*machgrid*velzgrid0d
!           machgridd = -(veldir(2)*ainf*velygrid0d) - veldir(1)*ainf*&
! &           velxgrid0d - veldir(3)*ainf*velzgrid0d
!           veldirfreestreamd = 0.0_8
!           velxgrid0d = 0.0_8
!           velzgrid0d = 0.0_8
!           velygrid0d = 0.0_8
!         else
!           ainfd = -(veldir(2)*machgrid*velygrid0d) - veldir(1)*machgrid*&
! &           velxgrid0d - veldir(3)*machgrid*velzgrid0d
!           machgridd = -(veldir(2)*ainf*velygrid0d) - veldir(1)*ainf*&
! &           velxgrid0d - veldir(3)*ainf*velzgrid0d
!           veldirfreestreamd = 0.0_8
!           velxgrid0d = 0.0_8
!           velzgrid0d = 0.0_8
!           velygrid0d = 0.0_8
!         end if
!       else
!         if (branch .ne. 5) then
!           velygrid0d = velygrid0d + rotationmatrix(3, 2)*velzgrid0d
!           velxgrid0d = velxgrid0d + rotationmatrix(2, 1)*velygrid0d + &
! &           rotationmatrix(3, 1)*velzgrid0d
!           velzgrid0d = rotationmatrix(2, 3)*velygrid0d + rotationmatrix(&
! &           1, 3)*velxgrid0d + rotationmatrix(3, 3)*velzgrid0d
!           velygrid0d = rotationmatrix(1, 2)*velxgrid0d + rotationmatrix(&
! &           2, 2)*velygrid0d
!           velxgrid0d = rotationmatrix(1, 1)*velxgrid0d
!         end if
!         veldirfreestreamd = 0.0_8
!         machgridd = 0.0_8
!         ainfd = 0.0_8
!       end if
!       call derivativerotmatrixrigid_b(derivrotationmatrix, &
! &                               derivrotationmatrixd, rotationpoint, t(1&
! &                               ))
!       ainfd = ainfd - veldirfreestream(2)*machgrid*velygrid0d - &
! &       veldirfreestream(1)*machgrid*velxgrid0d - veldirfreestream(3)*&
! &       machgrid*velzgrid0d
!       machgridd = machgridd - veldirfreestream(2)*ainf*velygrid0d - &
! &       veldirfreestream(1)*ainf*velxgrid0d - veldirfreestream(3)*ainf*&
! &       velzgrid0d
!       veldirfreestreamd(3) = veldirfreestreamd(3) - ainf*machgrid*&
! &       velzgrid0d
!       veldirfreestreamd(2) = veldirfreestreamd(2) - ainf*machgrid*&
! &       velygrid0d
!       veldirfreestreamd(1) = veldirfreestreamd(1) - ainf*machgrid*&
! &       velxgrid0d
!       temp = gammainf*pinf/rhoinf
!       if (temp .eq. 0.0_8) then
!         tempd = 0.0
!       else
!         tempd = ainfd/(2.0*sqrt(temp)*rhoinf)
!       end if
!       gammainfd = pinf*tempd
!       pinfd = gammainf*tempd
!       rhoinfd = -(temp*tempd)
!     end if
!   end subroutine slipvelocitiesfinelevel_block_b


  subroutine slipvelocitiesfinelevel_block_b(useoldcoor, t, sps)
!
!       slipvelocitiesfinelevel computes the slip velocities for
!       viscous subfaces on all viscous boundaries on groundlevel for
!       the given spectral solution. if useoldcoor is .true. the
!       velocities are determined using the unsteady time integrator;
!       otherwise the analytic form is used.
!
    use constants
    use inputtimespectral
! this gives nbkglobal
    use blockpointers
    use cgnsgrid
    use flowvarrefstate
    use inputmotion
    use inputunsteady
    use iteration
    use inputphysics
    use inputtsstabderiv
    use monitor
    use communication
    use flowutils_b, only : derivativerotmatrixrigid, &
&   derivativerotmatrixrigid_b, getdirvector, getdirvector_b
    use utils_b, only : tsalpha, tsbeta, tsmach, terminate, &
&   rotmatrixrigidbody, setcoeftimeintegrator, getdirangle
    implicit none
! mham: these nested loops have been replaced by fakenestedloop2
!    enddo
! enddo
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: useoldcoor
    real(kind=realtype), dimension(*), intent(in) :: t
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm, i, j, level
    real(kind=realtype) :: oneover4dt
    real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
    real(kind=realtype) :: velxgridd, velygridd, velzgridd, ainfd
    real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
    real(kind=realtype) :: velxgrid0d, velygrid0d, velzgrid0d
    real(kind=realtype), dimension(3) :: xc, xxc
    real(kind=realtype), dimension(3) :: xcd, xxcd
    real(kind=realtype), dimension(3) :: rotcenter, rotrate
    real(kind=realtype), dimension(3) :: rotrated
    real(kind=realtype), dimension(3) :: rotationpoint
    real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
&   derivrotationmatrix
    real(kind=realtype), dimension(3, 3) :: derivrotationmatrixd
    real(kind=realtype) :: tnew, told
! mham corrections for tapenade use
! real(kind=realtype), dimension(:,:,:),   pointer :: uslip
! real(kind=realtype), dimension(:,:,:),   pointer :: xface
! mham: we do not need xfaceold...
! real(kind=realtype), dimension(:,:,:,:), pointer :: xfaceold
!
! l. 2241 in bcdata.f90
! bcdata(mm)%uslip(ibeg:iend,jbeg:jend,3)
! this one we simply insert below. it is one-to-one. code will be longer
! / less readable but effectively unaltered
!
    real(kind=realtype) :: xface_x, xface_y, xface_z
    real(kind=realtype) :: xface_xd, xface_yd, xface_zd
    real(kind=realtype) :: xface_x_ij_10, xface_y_ij_10, xface_z_ij_10, &
&   xface_x_ij_01, xface_y_ij_01, xface_z_ij_01, xface_x_ij_11, &
&   xface_y_ij_11, xface_z_ij_11
    real(kind=realtype) :: xface_x_ij_10d, xface_y_ij_10d, &
&   xface_z_ij_10d, xface_x_ij_01d, xface_y_ij_01d, xface_z_ij_01d, &
&   xface_x_ij_11d, xface_y_ij_11d, xface_z_ij_11d
! real(kind=realtype)   :: xfaceold
! mham: now, we must remember to declare new counter used in the fake-loop
    integer :: ii, i_, j_
!        
    real(kind=realtype) :: intervalmach, alphats, alphaincrement, betats&
&   , betaincrement
    real(kind=realtype), dimension(3) :: veldir
    real(kind=realtype), dimension(3) :: refdirection
    intrinsic sqrt
    integer :: branch
    integer :: ad_from
    integer :: ad_to
    integer :: ad_from0
    integer :: ad_to0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! determine the situation we are having here.
    if (.not.useoldcoor) then
! mham: nothing here, since we set useoldcoor=.false.
!       everything has been cut out.
! the velocities must be determined analytically.
! compute the mesh velocity from the given mesh mach number.
!  ainf = sqrt(gammainf*pinf/rhoinf)
!  velxgrid = ainf*machgrid(1)
!  velygrid = ainf*machgrid(2)
!  velzgrid = ainf*machgrid(3)
      ainf = sqrt(gammainf*pinf/rhoinf)
! compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. it is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
      call derivativerotmatrixrigid(derivrotationmatrix, rotationpoint, &
&                             t(1))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
      if (tsstability) then
! determine the time values of the old and new time level.
! it is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
        tnew = timeunsteady + timeunsteadyrestart
        told = tnew - t(1)
        if ((tspmode .or. tsqmode) .or. tsrmode) then
! compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
          call rotmatrixrigidbody(tnew, told, rotationmatrix, &
&                           rotationpoint)
          if (tsalphafollowing) then
            call pushcontrol3b(6)
          else
            call pushcontrol3b(5)
          end if
        else if (tsalphamode) then
!determine the alpha for this time instance
          alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
&           degreefouralpha, omegafouralpha, coscoeffouralpha, &
&           sincoeffouralpha, t(1))
          alphats = alpha + alphaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector(refdirection, alphats, beta, veldir, &
&                     liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          call pushcontrol3b(4)
        else if (tsbetamode) then
!determine the alpha for this time instance
          betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
&           degreefourbeta, omegafourbeta, coscoeffourbeta, &
&           sincoeffourbeta, t(1))
          betats = beta + betaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector(refdirection, alpha, betats, veldir, &
&                     liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          call pushcontrol3b(3)
        else if (tsmachmode) then
!determine the mach number at this time interval
          intervalmach = tsmach(degreepolmach, coefpolmach, &
&           degreefourmach, omegafourmach, coscoeffourmach, &
&           sincoeffourmach, t(1))
!set the effective grid velocity
          call pushcontrol3b(2)
        else
          call pushcontrol3b(1)
        end if
      else
        call pushcontrol3b(0)
      end if
! loop over the number of viscous subfaces.
bocoloop2:do mm=1,nviscbocos
        ad_from0 = bcdata(mm)%jcbeg
        do j=ad_from0,bcdata(mm)%jcend
          ad_from = bcdata(mm)%icbeg
          do i=ad_from,bcdata(mm)%icend
! determine the grid face on which the subface is located
! and set some variables accordingly.
            select case  (bcfaceid(mm)) 
            case (imin) 
! xface => x(1,:,:,:)
              xface_x = x(1, i-1, j-1, 1)
              xface_y = x(1, i-1, j-1, 2)
              xface_z = x(1, i-1, j-1, 3)
              xface_x_ij_10 = x(1, i+1-1, j+0-1, 1)
              xface_y_ij_10 = x(1, i+1-1, j+0-1, 2)
              xface_z_ij_10 = x(1, i+1-1, j+0-1, 3)
              xface_x_ij_01 = x(1, i+0-1, j+1-1, 1)
              xface_y_ij_01 = x(1, i+0-1, j+1-1, 2)
              xface_z_ij_01 = x(1, i+0-1, j+1-1, 3)
              xface_x_ij_11 = x(1, i+1-1, j+1-1, 1)
              xface_y_ij_11 = x(1, i+1-1, j+1-1, 2)
              xface_z_ij_11 = x(1, i+1-1, j+1-1, 3)
              call pushcontrol3b(1)
            case (imax) 
! xface => x(il,:,:,:)
              xface_x = x(il, i-1, j-1, 1)
              xface_y = x(il, i-1, j-1, 2)
              xface_z = x(il, i-1, j-1, 3)
              xface_x_ij_10 = x(il, i+1-1, j+0-1, 1)
              xface_y_ij_10 = x(il, i+1-1, j+0-1, 2)
              xface_z_ij_10 = x(il, i+1-1, j+0-1, 3)
              xface_x_ij_01 = x(il, i+0-1, j+1-1, 1)
              xface_y_ij_01 = x(il, i+0-1, j+1-1, 2)
              xface_z_ij_01 = x(il, i+0-1, j+1-1, 3)
              xface_x_ij_11 = x(il, i+1-1, j+1-1, 1)
              xface_y_ij_11 = x(il, i+1-1, j+1-1, 2)
              xface_z_ij_11 = x(il, i+1-1, j+1-1, 3)
              call pushcontrol3b(2)
            case (jmin) 
! xface => x(:,1,:,:)
              xface_x = x(i-1, 1, j-1, 1)
              xface_y = x(i-1, 1, j-1, 2)
              xface_z = x(i-1, 1, j-1, 3)
              xface_x_ij_10 = x(i+1-1, 1, j+0-1, 1)
              xface_y_ij_10 = x(i+1-1, 1, j+0-1, 2)
              xface_z_ij_10 = x(i+1-1, 1, j+0-1, 3)
              xface_x_ij_01 = x(i+0-1, 1, j+1-1, 1)
              xface_y_ij_01 = x(i+0-1, 1, j+1-1, 2)
              xface_z_ij_01 = x(i+0-1, 1, j+1-1, 3)
              xface_x_ij_11 = x(i+1-1, 1, j+1-1, 1)
              xface_y_ij_11 = x(i+1-1, 1, j+1-1, 2)
              xface_z_ij_11 = x(i+1-1, 1, j+1-1, 3)
              call pushcontrol3b(3)
            case (jmax) 
! xface => x(:,jl,:,:)
              xface_x = x(i-1, jl, j-1, 1)
              xface_y = x(i-1, jl, j-1, 2)
              xface_z = x(i-1, jl, j-1, 3)
              xface_x_ij_10 = x(i+1-1, jl, j+0-1, 1)
              xface_y_ij_10 = x(i+1-1, jl, j+0-1, 2)
              xface_z_ij_10 = x(i+1-1, jl, j+0-1, 3)
              xface_x_ij_01 = x(i+0-1, jl, j+1-1, 1)
              xface_y_ij_01 = x(i+0-1, jl, j+1-1, 2)
              xface_z_ij_01 = x(i+0-1, jl, j+1-1, 3)
              xface_x_ij_11 = x(i+1-1, jl, j+1-1, 1)
              xface_y_ij_11 = x(i+1-1, jl, j+1-1, 2)
              xface_z_ij_11 = x(i+1-1, jl, j+1-1, 3)
              call pushcontrol3b(4)
            case (kmin) 
! xface => x(:,:,1,:)
              xface_x = x(i-1, j-1, 1, 1)
              xface_y = x(i-1, j-1, 1, 2)
              xface_z = x(i-1, j-1, 1, 3)
              xface_x_ij_10 = x(i+1-1, j+0-1, 1, 1)
              xface_y_ij_10 = x(i+1-1, j+0-1, 1, 2)
              xface_z_ij_10 = x(i+1-1, j+0-1, 1, 3)
              xface_x_ij_01 = x(i+0-1, j+1-1, 1, 1)
              xface_y_ij_01 = x(i+0-1, j+1-1, 1, 2)
              xface_z_ij_01 = x(i+0-1, j+1-1, 1, 3)
              xface_x_ij_11 = x(i+1-1, j+1-1, 1, 1)
              xface_y_ij_11 = x(i+1-1, j+1-1, 1, 2)
              xface_z_ij_11 = x(i+1-1, j+1-1, 1, 3)
              call pushcontrol3b(5)
            case (kmax) 
! xface => x(:,:,kl,:)
              xface_x = x(i-1, j-1, kl, 1)
              xface_y = x(i-1, j-1, kl, 2)
              xface_z = x(i-1, j-1, kl, 3)
              xface_x_ij_10 = x(i+1-1, j+0-1, kl, 1)
              xface_y_ij_10 = x(i+1-1, j+0-1, kl, 2)
              xface_z_ij_10 = x(i+1-1, j+0-1, kl, 3)
              xface_x_ij_01 = x(i+0-1, j+1-1, kl, 1)
              xface_y_ij_01 = x(i+0-1, j+1-1, kl, 2)
              xface_z_ij_01 = x(i+0-1, j+1-1, kl, 3)
              xface_x_ij_11 = x(i+1-1, j+1-1, kl, 1)
              xface_y_ij_11 = x(i+1-1, j+1-1, kl, 2)
              xface_z_ij_11 = x(i+1-1, j+1-1, kl, 3)
              call pushcontrol3b(6)
            case default
              call pushcontrol3b(0)
            end select
! store the rotation center and the rotation rate
! for this subface.
! mham: had to redo this a second time. if we do as stated below
! then tapenade will make a mistake! it will simply drop the
! initialization line of j_; "j_ = nbkglobal" and then we will
! get a runtime error on flux when we run the code since
! j_ has not been initialized properly. therefore, we will skip
! the j_ and the i_ altogether and insert nbkglobal and
! cgnssubface(mm) directly in the rotcenter and rotrate line...
! ! mham: notice we had to rename these two placeholders, (i,j)->
! ! (i_,j_) since i and j are now inside the i,j-double loop
! j_ = nbkglobal
! i_ = cgnssubface(mm)
            rotcenter = cgnsdoms(nbkglobal)%bocoinfo(cgnssubface(mm))%&
&             rotcenter
! mham: deprecated lines
! rotcenter = cgnsdoms(j_)%bocoinfo(i_)%rotcenter
! rotrate   = timeref*cgnsdoms(j_)%bocoinfo(i_)%rotrate
! usewindaxis should go back here!
! loop over the quadrilateral faces of the viscous
! subface.
! mham: this nested loop has been replaced by fakenestedloop2
! do j=bcdata(mm)%jcbeg, bcdata(mm)%jcend
!    do i=bcdata(mm)%icbeg, bcdata(mm)%icend
! compute the coordinates of the centroid of the face.
! normally this would be an average of i-1 and i, but
! due to the usage of the pointer xface and the fact
! that x starts at index 0 this is shifted 1 index.
! mham: this region is deprecated and has been replaced to
! allow for a more smooth tapenade differentiation w.o. any pointers
! xc(1) = fourth*(xface(i+1,j+1,1) + xface(i+1,j,1) &
!      +         xface(i,  j+1,1) + xface(i,  j,1))
! xc(2) = fourth*(xface(i+1,j+1,2) + xface(i+1,j,2) &
!      +         xface(i,  j+1,2) + xface(i,  j,2))
! xc(3) = fourth*(xface(i+1,j+1,3) + xface(i+1,j,3) &
!      +         xface(i,  j+1,3) + xface(i,  j,3))
            xc(1) = fourth*(xface_x_ij_11+xface_x_ij_10+xface_x_ij_01+&
&             xface_x)
            xc(2) = fourth*(xface_y_ij_11+xface_y_ij_10+xface_y_ij_01+&
&             xface_y)
            xc(3) = fourth*(xface_z_ij_11+xface_z_ij_10+xface_z_ij_01+&
&             xface_z)
! determine the coordinates relative to the center
! of rotation.
            call pushreal8(xxc(1))
            xxc(1) = xc(1) - rotcenter(1)
            call pushreal8(xxc(2))
            xxc(2) = xc(2) - rotcenter(2)
            call pushreal8(xxc(3))
            xxc(3) = xc(3) - rotcenter(3)
! compute the velocity, which is the cross product
! of rotrate and xc.
! determine the coordinates relative to the
! rigid body rotation point.
            call pushreal8(xxc(1))
            xxc(1) = xc(1) - rotationpoint(1)
            call pushreal8(xxc(2))
            xxc(2) = xc(2) - rotationpoint(2)
            call pushreal8(xxc(3))
            xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell center.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
          end do
          call pushinteger4(i - 1)
          call pushinteger4(ad_from)
        end do
        call pushinteger4(j - 1)
        call pushinteger4(ad_from0)
      end do bocoloop2
      xface_x_ij_10d = 0.0_8
      xface_x_ij_11d = 0.0_8
      velxgrid0d = 0.0_8
      velzgrid0d = 0.0_8
      xcd = 0.0_8
      xxcd = 0.0_8
      xface_z_ij_01d = 0.0_8
      derivrotationmatrixd = 0.0_8
      xface_y_ij_01d = 0.0_8
      velygrid0d = 0.0_8
      xface_z_ij_10d = 0.0_8
      xface_z_ij_11d = 0.0_8
      xface_x_ij_01d = 0.0_8
      xface_y_ij_10d = 0.0_8
      xface_y_ij_11d = 0.0_8
      xface_xd = 0.0_8
      xface_yd = 0.0_8
      xface_zd = 0.0_8
      do mm=nviscbocos,1,-1
        call popinteger4(ad_from0)
        call popinteger4(ad_to0)
        do j=ad_to0,ad_from0,-1
          call popinteger4(ad_from)
          call popinteger4(ad_to)
          do i=ad_to,ad_from,-1
            velzgridd = bcdatad(mm)%uslip(i, j, 3)
            derivrotationmatrixd(3, 1) = derivrotationmatrixd(3, 1) + &
&             xxc(1)*bcdatad(mm)%uslip(i, j, 3)
            xxcd(1) = xxcd(1) + derivrotationmatrix(3, 1)*bcdatad(mm)%&
&             uslip(i, j, 3)
            derivrotationmatrixd(3, 2) = derivrotationmatrixd(3, 2) + &
&             xxc(2)*bcdatad(mm)%uslip(i, j, 3)
            xxcd(2) = xxcd(2) + derivrotationmatrix(3, 2)*bcdatad(mm)%&
&             uslip(i, j, 3)
            derivrotationmatrixd(3, 3) = derivrotationmatrixd(3, 3) + &
&             xxc(3)*bcdatad(mm)%uslip(i, j, 3)
            xxcd(3) = xxcd(3) + derivrotationmatrix(3, 3)*bcdatad(mm)%&
&             uslip(i, j, 3)
            velygridd = bcdatad(mm)%uslip(i, j, 2)
            derivrotationmatrixd(2, 1) = derivrotationmatrixd(2, 1) + &
&             xxc(1)*bcdatad(mm)%uslip(i, j, 2)
            xxcd(1) = xxcd(1) + derivrotationmatrix(2, 1)*bcdatad(mm)%&
&             uslip(i, j, 2)
            derivrotationmatrixd(2, 2) = derivrotationmatrixd(2, 2) + &
&             xxc(2)*bcdatad(mm)%uslip(i, j, 2)
            xxcd(2) = xxcd(2) + derivrotationmatrix(2, 2)*bcdatad(mm)%&
&             uslip(i, j, 2)
            derivrotationmatrixd(2, 3) = derivrotationmatrixd(2, 3) + &
&             xxc(3)*bcdatad(mm)%uslip(i, j, 2)
            xxcd(3) = xxcd(3) + derivrotationmatrix(2, 3)*bcdatad(mm)%&
&             uslip(i, j, 2)
            velxgridd = bcdatad(mm)%uslip(i, j, 1)
            derivrotationmatrixd(1, 1) = derivrotationmatrixd(1, 1) + &
&             xxc(1)*bcdatad(mm)%uslip(i, j, 1)
            xxcd(1) = xxcd(1) + derivrotationmatrix(1, 1)*bcdatad(mm)%&
&             uslip(i, j, 1)
            derivrotationmatrixd(1, 2) = derivrotationmatrixd(1, 2) + &
&             xxc(2)*bcdatad(mm)%uslip(i, j, 1)
            xxcd(2) = xxcd(2) + derivrotationmatrix(1, 2)*bcdatad(mm)%&
&             uslip(i, j, 1)
            derivrotationmatrixd(1, 3) = derivrotationmatrixd(1, 3) + &
&             xxc(3)*bcdatad(mm)%uslip(i, j, 1)
            xxcd(3) = xxcd(3) + derivrotationmatrix(1, 3)*bcdatad(mm)%&
&             uslip(i, j, 1)
            call popreal8(xxc(3))
            xcd(3) = xcd(3) + xxcd(3)
            xxcd(3) = 0.0_8
            call popreal8(xxc(2))
            xcd(2) = xcd(2) + xxcd(2)
            xxcd(2) = 0.0_8
            call popreal8(xxc(1))
            xcd(1) = xcd(1) + xxcd(1)
            xxcd(1) = 0.0_8
            rotrate = timeref*cgnsdoms(nbkglobal)%bocoinfo(cgnssubface(&
&             mm))%rotrate
            rotrated = 0.0_8
            rotrated(1) = rotrated(1) + xxc(2)*bcdatad(mm)%uslip(i, j, 3&
&             )
            xxcd(2) = xxcd(2) + rotrate(1)*bcdatad(mm)%uslip(i, j, 3)
            rotrated(2) = rotrated(2) - xxc(1)*bcdatad(mm)%uslip(i, j, 3&
&             )
            xxcd(1) = xxcd(1) - rotrate(2)*bcdatad(mm)%uslip(i, j, 3)
            bcdatad(mm)%uslip(i, j, 3) = 0.0_8
            rotrated(3) = rotrated(3) + xxc(1)*bcdatad(mm)%uslip(i, j, 2&
&             )
            xxcd(1) = xxcd(1) + rotrate(3)*bcdatad(mm)%uslip(i, j, 2)
            rotrated(1) = rotrated(1) - xxc(3)*bcdatad(mm)%uslip(i, j, 2&
&             )
            xxcd(3) = xxcd(3) - rotrate(1)*bcdatad(mm)%uslip(i, j, 2)
            bcdatad(mm)%uslip(i, j, 2) = 0.0_8
            rotrated(2) = rotrated(2) + xxc(3)*bcdatad(mm)%uslip(i, j, 1&
&             )
            xxcd(3) = xxcd(3) + rotrate(2)*bcdatad(mm)%uslip(i, j, 1)
            rotrated(3) = rotrated(3) - xxc(2)*bcdatad(mm)%uslip(i, j, 1&
&             )
            xxcd(2) = xxcd(2) - rotrate(3)*bcdatad(mm)%uslip(i, j, 1)
            bcdatad(mm)%uslip(i, j, 1) = 0.0_8
            call popreal8(xxc(3))
            xcd(3) = xcd(3) + xxcd(3)
            xxcd(3) = 0.0_8
            call popreal8(xxc(2))
            xcd(2) = xcd(2) + xxcd(2)
            xxcd(2) = 0.0_8
            call popreal8(xxc(1))
            xcd(1) = xcd(1) + xxcd(1)
            xxcd(1) = 0.0_8
            tempd0 = fourth*xcd(3)
            xface_z_ij_11d = xface_z_ij_11d + tempd0
            xface_z_ij_10d = xface_z_ij_10d + tempd0
            xface_z_ij_01d = xface_z_ij_01d + tempd0
            xface_zd = xface_zd + tempd0
            xcd(3) = 0.0_8
            tempd1 = fourth*xcd(2)
            xface_y_ij_11d = xface_y_ij_11d + tempd1
            xface_y_ij_10d = xface_y_ij_10d + tempd1
            xface_y_ij_01d = xface_y_ij_01d + tempd1
            xface_yd = xface_yd + tempd1
            xcd(2) = 0.0_8
            tempd2 = fourth*xcd(1)
            xface_x_ij_11d = xface_x_ij_11d + tempd2
            xface_x_ij_10d = xface_x_ij_10d + tempd2
            xface_x_ij_01d = xface_x_ij_01d + tempd2
            xface_xd = xface_xd + tempd2
            xcd(1) = 0.0_8
            velzgrid0d = velzgrid0d + velzgridd
            velygrid0d = velygrid0d + velygridd
            velxgrid0d = velxgrid0d + velxgridd
            timerefd = timerefd + sum(cgnsdoms(nbkglobal)%bocoinfo(&
&             cgnssubface(mm))%rotrate*rotrated)
            call popcontrol3b(branch)
            if (branch .lt. 3) then
              if (branch .ne. 0) then
                if (branch .eq. 1) then
                  xd(1, i+1-1, j+1-1, 3) = xd(1, i+1-1, j+1-1, 3) + &
&                   xface_z_ij_11d
                  xd(1, i+1-1, j+1-1, 2) = xd(1, i+1-1, j+1-1, 2) + &
&                   xface_y_ij_11d
                  xd(1, i+1-1, j+1-1, 1) = xd(1, i+1-1, j+1-1, 1) + &
&                   xface_x_ij_11d
                  xd(1, i+0-1, j+1-1, 3) = xd(1, i+0-1, j+1-1, 3) + &
&                   xface_z_ij_01d
                  xd(1, i+0-1, j+1-1, 2) = xd(1, i+0-1, j+1-1, 2) + &
&                   xface_y_ij_01d
                  xd(1, i+0-1, j+1-1, 1) = xd(1, i+0-1, j+1-1, 1) + &
&                   xface_x_ij_01d
                  xd(1, i+1-1, j+0-1, 3) = xd(1, i+1-1, j+0-1, 3) + &
&                   xface_z_ij_10d
                  xd(1, i+1-1, j+0-1, 2) = xd(1, i+1-1, j+0-1, 2) + &
&                   xface_y_ij_10d
                  xd(1, i+1-1, j+0-1, 1) = xd(1, i+1-1, j+0-1, 1) + &
&                   xface_x_ij_10d
                  xd(1, i-1, j-1, 3) = xd(1, i-1, j-1, 3) + xface_zd
                  xd(1, i-1, j-1, 2) = xd(1, i-1, j-1, 2) + xface_yd
                  xd(1, i-1, j-1, 1) = xd(1, i-1, j-1, 1) + xface_xd
                  xface_x_ij_10d = 0.0_8
                  xface_x_ij_11d = 0.0_8
                  xface_z_ij_01d = 0.0_8
                  xface_y_ij_01d = 0.0_8
                  xface_z_ij_10d = 0.0_8
                  xface_z_ij_11d = 0.0_8
                  xface_x_ij_01d = 0.0_8
                  xface_y_ij_10d = 0.0_8
                  xface_y_ij_11d = 0.0_8
                  xface_xd = 0.0_8
                  xface_yd = 0.0_8
                  xface_zd = 0.0_8
                else
                  xd(il, i+1-1, j+1-1, 3) = xd(il, i+1-1, j+1-1, 3) + &
&                   xface_z_ij_11d
                  xd(il, i+1-1, j+1-1, 2) = xd(il, i+1-1, j+1-1, 2) + &
&                   xface_y_ij_11d
                  xd(il, i+1-1, j+1-1, 1) = xd(il, i+1-1, j+1-1, 1) + &
&                   xface_x_ij_11d
                  xd(il, i+0-1, j+1-1, 3) = xd(il, i+0-1, j+1-1, 3) + &
&                   xface_z_ij_01d
                  xd(il, i+0-1, j+1-1, 2) = xd(il, i+0-1, j+1-1, 2) + &
&                   xface_y_ij_01d
                  xd(il, i+0-1, j+1-1, 1) = xd(il, i+0-1, j+1-1, 1) + &
&                   xface_x_ij_01d
                  xd(il, i+1-1, j+0-1, 3) = xd(il, i+1-1, j+0-1, 3) + &
&                   xface_z_ij_10d
                  xd(il, i+1-1, j+0-1, 2) = xd(il, i+1-1, j+0-1, 2) + &
&                   xface_y_ij_10d
                  xd(il, i+1-1, j+0-1, 1) = xd(il, i+1-1, j+0-1, 1) + &
&                   xface_x_ij_10d
                  xd(il, i-1, j-1, 3) = xd(il, i-1, j-1, 3) + xface_zd
                  xd(il, i-1, j-1, 2) = xd(il, i-1, j-1, 2) + xface_yd
                  xd(il, i-1, j-1, 1) = xd(il, i-1, j-1, 1) + xface_xd
                  xface_x_ij_10d = 0.0_8
                  xface_x_ij_11d = 0.0_8
                  xface_z_ij_01d = 0.0_8
                  xface_y_ij_01d = 0.0_8
                  xface_z_ij_10d = 0.0_8
                  xface_z_ij_11d = 0.0_8
                  xface_x_ij_01d = 0.0_8
                  xface_y_ij_10d = 0.0_8
                  xface_y_ij_11d = 0.0_8
                  xface_xd = 0.0_8
                  xface_yd = 0.0_8
                  xface_zd = 0.0_8
                end if
              end if
            else if (branch .lt. 5) then
              if (branch .eq. 3) then
                xd(i+1-1, 1, j+1-1, 3) = xd(i+1-1, 1, j+1-1, 3) + &
&                 xface_z_ij_11d
                xd(i+1-1, 1, j+1-1, 2) = xd(i+1-1, 1, j+1-1, 2) + &
&                 xface_y_ij_11d
                xd(i+1-1, 1, j+1-1, 1) = xd(i+1-1, 1, j+1-1, 1) + &
&                 xface_x_ij_11d
                xd(i+0-1, 1, j+1-1, 3) = xd(i+0-1, 1, j+1-1, 3) + &
&                 xface_z_ij_01d
                xd(i+0-1, 1, j+1-1, 2) = xd(i+0-1, 1, j+1-1, 2) + &
&                 xface_y_ij_01d
                xd(i+0-1, 1, j+1-1, 1) = xd(i+0-1, 1, j+1-1, 1) + &
&                 xface_x_ij_01d
                xd(i+1-1, 1, j+0-1, 3) = xd(i+1-1, 1, j+0-1, 3) + &
&                 xface_z_ij_10d
                xd(i+1-1, 1, j+0-1, 2) = xd(i+1-1, 1, j+0-1, 2) + &
&                 xface_y_ij_10d
                xd(i+1-1, 1, j+0-1, 1) = xd(i+1-1, 1, j+0-1, 1) + &
&                 xface_x_ij_10d
                xd(i-1, 1, j-1, 3) = xd(i-1, 1, j-1, 3) + xface_zd
                xd(i-1, 1, j-1, 2) = xd(i-1, 1, j-1, 2) + xface_yd
                xd(i-1, 1, j-1, 1) = xd(i-1, 1, j-1, 1) + xface_xd
                xface_x_ij_10d = 0.0_8
                xface_x_ij_11d = 0.0_8
                xface_z_ij_01d = 0.0_8
                xface_y_ij_01d = 0.0_8
                xface_z_ij_10d = 0.0_8
                xface_z_ij_11d = 0.0_8
                xface_x_ij_01d = 0.0_8
                xface_y_ij_10d = 0.0_8
                xface_y_ij_11d = 0.0_8
                xface_xd = 0.0_8
                xface_yd = 0.0_8
                xface_zd = 0.0_8
              else
                xd(i+1-1, jl, j+1-1, 3) = xd(i+1-1, jl, j+1-1, 3) + &
&                 xface_z_ij_11d
                xd(i+1-1, jl, j+1-1, 2) = xd(i+1-1, jl, j+1-1, 2) + &
&                 xface_y_ij_11d
                xd(i+1-1, jl, j+1-1, 1) = xd(i+1-1, jl, j+1-1, 1) + &
&                 xface_x_ij_11d
                xd(i+0-1, jl, j+1-1, 3) = xd(i+0-1, jl, j+1-1, 3) + &
&                 xface_z_ij_01d
                xd(i+0-1, jl, j+1-1, 2) = xd(i+0-1, jl, j+1-1, 2) + &
&                 xface_y_ij_01d
                xd(i+0-1, jl, j+1-1, 1) = xd(i+0-1, jl, j+1-1, 1) + &
&                 xface_x_ij_01d
                xd(i+1-1, jl, j+0-1, 3) = xd(i+1-1, jl, j+0-1, 3) + &
&                 xface_z_ij_10d
                xd(i+1-1, jl, j+0-1, 2) = xd(i+1-1, jl, j+0-1, 2) + &
&                 xface_y_ij_10d
                xd(i+1-1, jl, j+0-1, 1) = xd(i+1-1, jl, j+0-1, 1) + &
&                 xface_x_ij_10d
                xd(i-1, jl, j-1, 3) = xd(i-1, jl, j-1, 3) + xface_zd
                xd(i-1, jl, j-1, 2) = xd(i-1, jl, j-1, 2) + xface_yd
                xd(i-1, jl, j-1, 1) = xd(i-1, jl, j-1, 1) + xface_xd
                xface_x_ij_10d = 0.0_8
                xface_x_ij_11d = 0.0_8
                xface_z_ij_01d = 0.0_8
                xface_y_ij_01d = 0.0_8
                xface_z_ij_10d = 0.0_8
                xface_z_ij_11d = 0.0_8
                xface_x_ij_01d = 0.0_8
                xface_y_ij_10d = 0.0_8
                xface_y_ij_11d = 0.0_8
                xface_xd = 0.0_8
                xface_yd = 0.0_8
                xface_zd = 0.0_8
              end if
            else if (branch .eq. 5) then
              xd(i+1-1, j+1-1, 1, 3) = xd(i+1-1, j+1-1, 1, 3) + &
&               xface_z_ij_11d
              xd(i+1-1, j+1-1, 1, 2) = xd(i+1-1, j+1-1, 1, 2) + &
&               xface_y_ij_11d
              xd(i+1-1, j+1-1, 1, 1) = xd(i+1-1, j+1-1, 1, 1) + &
&               xface_x_ij_11d
              xd(i+0-1, j+1-1, 1, 3) = xd(i+0-1, j+1-1, 1, 3) + &
&               xface_z_ij_01d
              xd(i+0-1, j+1-1, 1, 2) = xd(i+0-1, j+1-1, 1, 2) + &
&               xface_y_ij_01d
              xd(i+0-1, j+1-1, 1, 1) = xd(i+0-1, j+1-1, 1, 1) + &
&               xface_x_ij_01d
              xd(i+1-1, j+0-1, 1, 3) = xd(i+1-1, j+0-1, 1, 3) + &
&               xface_z_ij_10d
              xd(i+1-1, j+0-1, 1, 2) = xd(i+1-1, j+0-1, 1, 2) + &
&               xface_y_ij_10d
              xd(i+1-1, j+0-1, 1, 1) = xd(i+1-1, j+0-1, 1, 1) + &
&               xface_x_ij_10d
              xd(i-1, j-1, 1, 3) = xd(i-1, j-1, 1, 3) + xface_zd
              xd(i-1, j-1, 1, 2) = xd(i-1, j-1, 1, 2) + xface_yd
              xd(i-1, j-1, 1, 1) = xd(i-1, j-1, 1, 1) + xface_xd
              xface_x_ij_10d = 0.0_8
              xface_x_ij_11d = 0.0_8
              xface_z_ij_01d = 0.0_8
              xface_y_ij_01d = 0.0_8
              xface_z_ij_10d = 0.0_8
              xface_z_ij_11d = 0.0_8
              xface_x_ij_01d = 0.0_8
              xface_y_ij_10d = 0.0_8
              xface_y_ij_11d = 0.0_8
              xface_xd = 0.0_8
              xface_yd = 0.0_8
              xface_zd = 0.0_8
            else
              xd(i+1-1, j+1-1, kl, 3) = xd(i+1-1, j+1-1, kl, 3) + &
&               xface_z_ij_11d
              xd(i+1-1, j+1-1, kl, 2) = xd(i+1-1, j+1-1, kl, 2) + &
&               xface_y_ij_11d
              xd(i+1-1, j+1-1, kl, 1) = xd(i+1-1, j+1-1, kl, 1) + &
&               xface_x_ij_11d
              xd(i+0-1, j+1-1, kl, 3) = xd(i+0-1, j+1-1, kl, 3) + &
&               xface_z_ij_01d
              xd(i+0-1, j+1-1, kl, 2) = xd(i+0-1, j+1-1, kl, 2) + &
&               xface_y_ij_01d
              xd(i+0-1, j+1-1, kl, 1) = xd(i+0-1, j+1-1, kl, 1) + &
&               xface_x_ij_01d
              xd(i+1-1, j+0-1, kl, 3) = xd(i+1-1, j+0-1, kl, 3) + &
&               xface_z_ij_10d
              xd(i+1-1, j+0-1, kl, 2) = xd(i+1-1, j+0-1, kl, 2) + &
&               xface_y_ij_10d
              xd(i+1-1, j+0-1, kl, 1) = xd(i+1-1, j+0-1, kl, 1) + &
&               xface_x_ij_10d
              xd(i-1, j-1, kl, 3) = xd(i-1, j-1, kl, 3) + xface_zd
              xd(i-1, j-1, kl, 2) = xd(i-1, j-1, kl, 2) + xface_yd
              xd(i-1, j-1, kl, 1) = xd(i-1, j-1, kl, 1) + xface_xd
              xface_x_ij_10d = 0.0_8
              xface_x_ij_11d = 0.0_8
              xface_z_ij_01d = 0.0_8
              xface_y_ij_01d = 0.0_8
              xface_z_ij_10d = 0.0_8
              xface_z_ij_11d = 0.0_8
              xface_x_ij_01d = 0.0_8
              xface_y_ij_10d = 0.0_8
              xface_y_ij_11d = 0.0_8
              xface_xd = 0.0_8
              xface_yd = 0.0_8
              xface_zd = 0.0_8
            end if
          end do
        end do
      end do
      call popcontrol3b(branch)
      if (branch .lt. 3) then
        if (branch .eq. 0) then
          ainfd = 0.0_8
        else if (branch .eq. 1) then
          ainfd = 0.0_8
        else
          machgridd = machgridd - ainf*veldirfreestream(2)*velygrid0d - &
&           ainf*veldirfreestream(1)*velxgrid0d - ainf*veldirfreestream(&
&           3)*velzgrid0d
          ainfd = -((intervalmach+machgrid)*veldirfreestream(2)*&
&           velygrid0d) - (intervalmach+machgrid)*veldirfreestream(1)*&
&           velxgrid0d - (intervalmach+machgrid)*veldirfreestream(3)*&
&           velzgrid0d
          veldirfreestreamd(3) = veldirfreestreamd(3) - (intervalmach+&
&           machgrid)*ainf*velzgrid0d
          veldirfreestreamd(2) = veldirfreestreamd(2) - (intervalmach+&
&           machgrid)*ainf*velygrid0d
          veldirfreestreamd(1) = veldirfreestreamd(1) - (intervalmach+&
&           machgrid)*ainf*velxgrid0d
          velxgrid0d = 0.0_8
          velzgrid0d = 0.0_8
          velygrid0d = 0.0_8
        end if
      else if (branch .lt. 5) then
        if (branch .eq. 3) then
          ainfd = -(veldir(2)*machgrid*velygrid0d) - veldir(1)*machgrid*&
&           velxgrid0d - veldir(3)*machgrid*velzgrid0d
          machgridd = machgridd - veldir(2)*ainf*velygrid0d - veldir(1)*&
&           ainf*velxgrid0d - veldir(3)*ainf*velzgrid0d
          velxgrid0d = 0.0_8
          velzgrid0d = 0.0_8
          velygrid0d = 0.0_8
        else
          ainfd = -(veldir(2)*machgrid*velygrid0d) - veldir(1)*machgrid*&
&           velxgrid0d - veldir(3)*machgrid*velzgrid0d
          machgridd = machgridd - veldir(2)*ainf*velygrid0d - veldir(1)*&
&           ainf*velxgrid0d - veldir(3)*ainf*velzgrid0d
          velxgrid0d = 0.0_8
          velzgrid0d = 0.0_8
          velygrid0d = 0.0_8
        end if
      else
        if (branch .ne. 5) then
          velygrid0d = velygrid0d + rotationmatrix(3, 2)*velzgrid0d
          velxgrid0d = velxgrid0d + rotationmatrix(2, 1)*velygrid0d + &
&           rotationmatrix(3, 1)*velzgrid0d
          velzgrid0d = rotationmatrix(2, 3)*velygrid0d + rotationmatrix(&
&           1, 3)*velxgrid0d + rotationmatrix(3, 3)*velzgrid0d
          velygrid0d = rotationmatrix(1, 2)*velxgrid0d + rotationmatrix(&
&           2, 2)*velygrid0d
          velxgrid0d = rotationmatrix(1, 1)*velxgrid0d
        end if
        ainfd = 0.0_8
      end if
      call derivativerotmatrixrigid_b(derivrotationmatrix, &
&                               derivrotationmatrixd, rotationpoint, t(1&
&                               ))
      ainfd = ainfd - veldirfreestream(2)*machgrid*velygrid0d - &
&       veldirfreestream(1)*machgrid*velxgrid0d - veldirfreestream(3)*&
&       machgrid*velzgrid0d
      machgridd = machgridd - veldirfreestream(2)*ainf*velygrid0d - &
&       veldirfreestream(1)*ainf*velxgrid0d - veldirfreestream(3)*ainf*&
&       velzgrid0d
      veldirfreestreamd(3) = veldirfreestreamd(3) - ainf*machgrid*&
&       velzgrid0d
      veldirfreestreamd(2) = veldirfreestreamd(2) - ainf*machgrid*&
&       velygrid0d
      veldirfreestreamd(1) = veldirfreestreamd(1) - ainf*machgrid*&
&       velxgrid0d
      temp = gammainf*pinf/rhoinf
      if (temp .eq. 0.0_8) then
        tempd = 0.0
      else
        tempd = ainfd/(2.0*sqrt(temp)*rhoinf)
      end if
      gammainfd = gammainfd + pinf*tempd
      pinfd = pinfd + gammainf*tempd
      rhoinfd = rhoinfd - temp*tempd
    end if
  end subroutine slipvelocitiesfinelevel_block_b
! mham addition






!  differentiation of normalvelocities_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*bcdata.rface)
!   with respect to varying inputs: *sfacei *sfacej *sfacek *si
!                *sj *sk *(*bcdata.rface)
!   rw status of diff variables: *sfacei:out *sfacej:out *sfacek:out
!                *si:out *sj:out *sk:out *(*bcdata.rface):in-out
!   plus diff mem management of: sfacei:in sfacej:in sfacek:in
!                si:in sj:in sk:in bcdata:in *bcdata.rface:in
! mham addition
  subroutine normalvelocities_block_b(sps)
!
!       normalvelocitiesalllevels computes the normal grid
!       velocities of some boundary faces of the moving blocks for
!       spectral mode sps. all grid levels from ground level to the
!       coarsest level are considered.
!
    use constants
    use blockpointers, only : il, jl, kl, addgridvelocities, nbocos, &
&   bcdata, bcdatad, sfacei, sfaceid, sfacej, sfacejd, sfacek, sfacekd, &
&   bcfaceid, si, sid, sj, sjd, sk, skd
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
!
!      local variables.
!
    integer(kind=inttype) :: mm
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: weight, mult
    real(kind=realtype) :: weightd
! mham: comment out deprecated pointers
! real(kind=realtype), dimension(:,:),   pointer :: sface  
! real(kind=realtype), dimension(:,:,:), pointer :: ss
    real(kind=realtype) :: sface_ij
    real(kind=realtype) :: sface_ijd
    real(kind=realtype) :: ss_x, ss_y, ss_z
    real(kind=realtype) :: ss_xd, ss_yd, ss_zd
! mham: we also need a pointer for the fake double loop:
    integer(kind=inttype) :: ii_
    intrinsic associated
    intrinsic mod
    intrinsic sqrt
    integer :: branch
    integer :: ad_to
    real(kind=realtype) :: tempd
! check for a moving block. as it is possible that in a
! multidisicplinary environment additional grid velocities
! are set, the test should be done on addgridvelocities
! and not on blockismoving.
    if (addgridvelocities) then
!
!             determine the normal grid velocities of the boundaries.
!             as these values are based on the unit normal. a division
!             by the length of the normal is needed.
!             furthermore the boundary unit normals are per definition
!             outward pointing, while on the imin, jmin and kmin
!             boundaries the face normals are inward pointing. this
!             is taken into account by the factor mult.
!
! loop over the boundary subfaces.
bocoloop:do mm=1,nbocos
! check whether rface is allocated.
        if (associated(bcdata(mm)%rface)) then
! determine the block face on which the subface is
! located and set some variables accordingly.
fakedoubleloop:do ii_=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm&
&             )%icend-bcdata(mm)%icbeg+1)-1
            j = ii_/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%&
&             jcbeg
            call pushinteger4(i)
            i = mod(ii_, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + &
&             bcdata(mm)%icbeg
            select case  (bcfaceid(mm)) 
            case (imin) 
              call pushreal8(mult)
              mult = -one
! ss => si(1,:,:,:)
              call pushreal8(ss_x)
              ss_x = si(1, i, j, 1)
              call pushreal8(ss_y)
              ss_y = si(1, i, j, 2)
              call pushreal8(ss_z)
              ss_z = si(1, i, j, 3)
! sface => sfacei(1,:,:)
              call pushreal8(sface_ij)
              sface_ij = sfacei(1, i, j)
              call pushcontrol3b(1)
            case (imax) 
              call pushreal8(mult)
              mult = one
! ss => si(il,:,:,:)
              call pushreal8(ss_x)
              ss_x = si(il, i, j, 1)
              call pushreal8(ss_y)
              ss_y = si(il, i, j, 2)
              call pushreal8(ss_z)
              ss_z = si(il, i, j, 3)
! sface => sfacei(il,:,:)
              call pushreal8(sface_ij)
              sface_ij = sfacei(il, i, j)
              call pushcontrol3b(2)
            case (jmin) 
              call pushreal8(mult)
              mult = -one
! ss => sj(:,1,:,:) 
              call pushreal8(ss_x)
              ss_x = sj(i, 1, j, 1)
              call pushreal8(ss_y)
              ss_y = sj(i, 1, j, 2)
              call pushreal8(ss_z)
              ss_z = sj(i, 1, j, 3)
! sface => sfacej(:,1,:)
              call pushreal8(sface_ij)
              sface_ij = sfacej(i, 1, j)
              call pushcontrol3b(3)
            case (jmax) 
              call pushreal8(mult)
              mult = one
! ss => sj(:,jl,:,:)
              call pushreal8(ss_x)
              ss_x = sj(i, jl, j, 1)
              call pushreal8(ss_y)
              ss_y = sj(i, jl, j, 2)
              call pushreal8(ss_z)
              ss_z = sj(i, jl, j, 3)
! sface => sfacej(:,jl,:)
              call pushreal8(sface_ij)
              sface_ij = sfacej(i, jl, j)
              call pushcontrol3b(4)
            case (kmin) 
              call pushreal8(mult)
              mult = -one
! ss => sk(:,:,1,:)
              call pushreal8(ss_x)
              ss_x = sk(i, j, 1, 1)
              call pushreal8(ss_y)
              ss_y = sk(i, j, 1, 2)
              call pushreal8(ss_z)
              ss_z = sk(i, j, 1, 3)
! sface => sfacek(:,:,1)
              call pushreal8(sface_ij)
              sface_ij = sfacek(i, j, 1)
              call pushcontrol3b(5)
            case (kmax) 
              call pushreal8(mult)
              mult = one
! ss => sk(:,:,kl,:)
              call pushreal8(ss_x)
              ss_x = sk(i, j, kl, 1)
              call pushreal8(ss_y)
              ss_y = sk(i, j, kl, 2)
              call pushreal8(ss_z)
              ss_z = sk(i, j, kl, 3)
! sface => sfacek(:,:,kl)
              call pushreal8(sface_ij)
              sface_ij = sfacek(i, j, kl)
              call pushcontrol3b(6)
            case default
              call pushcontrol3b(0)
            end select
! loop over the faces of the subface.
! mham: remove nested pointer loop
! do j=bcdata(mm)%jcbeg, bcdata(mm)%jcend
!    do i=bcdata(mm)%icbeg, bcdata(mm)%icend
! compute the inverse of the length of the normal
! vector and possibly correct for inward pointing.
! mham: remove old pointer version
! weight = sqrt(ss(i,j,1)**2 + ss(i,j,2)**2 &
!      +      ss(i,j,3)**2)
! mham: insert new fake pointers
            call pushreal8(weight)
            weight = sqrt(ss_x**2 + ss_y**2 + ss_z**2)
            if (weight .gt. zero) then
              call pushreal8(weight)
              weight = mult/weight
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
            end if
          end do fakedoubleloop
          call pushinteger4(ii_ - 1)
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do bocoloop
      sface_ijd = 0.0_8
      ss_xd = 0.0_8
      ss_yd = 0.0_8
      ss_zd = 0.0_8
      do mm=nbocos,1,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          call popinteger4(ad_to)
          do ii_=ad_to,0,-1
            j = ii_/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%&
&             jcbeg
            weightd = sface_ij*bcdatad(mm)%rface(i, j)
            sface_ijd = sface_ijd + weight*bcdatad(mm)%rface(i, j)
            bcdatad(mm)%rface(i, j) = 0.0_8
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(weight)
              weightd = -(mult*weightd/weight**2)
            end if
            call popreal8(weight)
            if (ss_x**2 + ss_y**2 + ss_z**2 .eq. 0.0_8) then
              tempd = 0.0
            else
              tempd = weightd/(2.0*sqrt(ss_x**2+ss_y**2+ss_z**2))
            end if
            ss_xd = ss_xd + 2*ss_x*tempd
            ss_yd = ss_yd + 2*ss_y*tempd
            ss_zd = ss_zd + 2*ss_z*tempd
            call popcontrol3b(branch)
            if (branch .lt. 3) then
              if (branch .ne. 0) then
                if (branch .eq. 1) then
                  call popreal8(sface_ij)
                  sfaceid(1, i, j) = sfaceid(1, i, j) + sface_ijd
                  call popreal8(ss_z)
                  sid(1, i, j, 3) = sid(1, i, j, 3) + ss_zd
                  call popreal8(ss_y)
                  sid(1, i, j, 2) = sid(1, i, j, 2) + ss_yd
                  call popreal8(ss_x)
                  sid(1, i, j, 1) = sid(1, i, j, 1) + ss_xd
                  call popreal8(mult)
                  sface_ijd = 0.0_8
                  ss_xd = 0.0_8
                  ss_yd = 0.0_8
                  ss_zd = 0.0_8
                else
                  call popreal8(sface_ij)
                  sfaceid(il, i, j) = sfaceid(il, i, j) + sface_ijd
                  call popreal8(ss_z)
                  sid(il, i, j, 3) = sid(il, i, j, 3) + ss_zd
                  call popreal8(ss_y)
                  sid(il, i, j, 2) = sid(il, i, j, 2) + ss_yd
                  call popreal8(ss_x)
                  sid(il, i, j, 1) = sid(il, i, j, 1) + ss_xd
                  call popreal8(mult)
                  sface_ijd = 0.0_8
                  ss_xd = 0.0_8
                  ss_yd = 0.0_8
                  ss_zd = 0.0_8
                end if
              end if
            else if (branch .lt. 5) then
              if (branch .eq. 3) then
                call popreal8(sface_ij)
                sfacejd(i, 1, j) = sfacejd(i, 1, j) + sface_ijd
                call popreal8(ss_z)
                sjd(i, 1, j, 3) = sjd(i, 1, j, 3) + ss_zd
                call popreal8(ss_y)
                sjd(i, 1, j, 2) = sjd(i, 1, j, 2) + ss_yd
                call popreal8(ss_x)
                sjd(i, 1, j, 1) = sjd(i, 1, j, 1) + ss_xd
                call popreal8(mult)
                sface_ijd = 0.0_8
                ss_xd = 0.0_8
                ss_yd = 0.0_8
                ss_zd = 0.0_8
              else
                call popreal8(sface_ij)
                sfacejd(i, jl, j) = sfacejd(i, jl, j) + sface_ijd
                call popreal8(ss_z)
                sjd(i, jl, j, 3) = sjd(i, jl, j, 3) + ss_zd
                call popreal8(ss_y)
                sjd(i, jl, j, 2) = sjd(i, jl, j, 2) + ss_yd
                call popreal8(ss_x)
                sjd(i, jl, j, 1) = sjd(i, jl, j, 1) + ss_xd
                call popreal8(mult)
                sface_ijd = 0.0_8
                ss_xd = 0.0_8
                ss_yd = 0.0_8
                ss_zd = 0.0_8
              end if
            else if (branch .eq. 5) then
              call popreal8(sface_ij)
              sfacekd(i, j, 1) = sfacekd(i, j, 1) + sface_ijd
              call popreal8(ss_z)
              skd(i, j, 1, 3) = skd(i, j, 1, 3) + ss_zd
              call popreal8(ss_y)
              skd(i, j, 1, 2) = skd(i, j, 1, 2) + ss_yd
              call popreal8(ss_x)
              skd(i, j, 1, 1) = skd(i, j, 1, 1) + ss_xd
              call popreal8(mult)
              sface_ijd = 0.0_8
              ss_xd = 0.0_8
              ss_yd = 0.0_8
              ss_zd = 0.0_8
            else
              call popreal8(sface_ij)
              sfacekd(i, j, kl) = sfacekd(i, j, kl) + sface_ijd
              call popreal8(ss_z)
              skd(i, j, kl, 3) = skd(i, j, kl, 3) + ss_zd
              call popreal8(ss_y)
              skd(i, j, kl, 2) = skd(i, j, kl, 2) + ss_yd
              call popreal8(ss_x)
              skd(i, j, kl, 1) = skd(i, j, kl, 1) + ss_xd
              call popreal8(mult)
              sface_ijd = 0.0_8
              ss_xd = 0.0_8
              ss_yd = 0.0_8
              ss_zd = 0.0_8
            end if
            call popinteger4(i)
          end do
        end if
      end do
    else
! mham: remember to remove old enddo's from
!       nested pointer loop
!    enddo
! enddo
! mham: remember to close the fake loop
! block is not moving. loop over the boundary faces and set
! the normal grid velocity to zero if allocated.
      do mm=1,nbocos
        if (associated(bcdata(mm)%rface)) then
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do
      do mm=nbocos,1,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) bcdatad(mm)%rface = 0.0_8
      end do
    end if
  end subroutine normalvelocities_block_b
! mham addition



end module adjointextra_b
